---
title: "scATACseq - Complete Seurat procedure"
subtitle: "Dernière modification : `r format(Sys.time(), '%d %B, %Y')`"
author: "Romuald - Laëtitia"
date: "27/01/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

*Résumé du code* : ce script permet d'analyser les données du point scATACseq sur des cellules cultivées pendant 24h en MP.  
La première partie correspond à une prise en main de la manipulation des objets Seurat.  
La deuxième partie permet de vérifier la qualité des données récupérées.  
**Code inspiré de** : https://satijalab.org/signac/articles/pbmc_vignette.html 

```{r Libraries, message=F, echo=FALSE, warning=FALSE, results='hide'}

library(Signac) # addon to Seurat library to work with scATACseq data
library(Seurat)
library(GenomeInfoDb) # Database with genome information
library(EnsDb.Hsapiens.v86) # v.86= hg38 | v.75=hg19
library(ggplot2)
library(patchwork)
library(readr)
library(dplyr)
library(cowplot)
library(clusterProfiler) # to perform gene ontology analysis
library(tidyverse) # to use mutate_all
library(kableExtra)

```

```{r Working directories}

dir_git = "~/Bureau/sc_ATAC_analysis/Git_sc_ATAC_analysis/"
dir_input = "~/Bureau/scATAC_raw_data/ATAC_Ctrl_MP/"
dir_output = "~/Bureau/sc_ATAC_analysis/Git_sc_ATAC_analysis/exp/complete_Seurat_procedure/"
currentDate <- paste0(substr(Sys.Date(), 1,4), substr(Sys.Date(),6,7), substr(Sys.Date(),9, 10))
# currentDate = "20220224"
dir.create(path = paste0(dir_output, currentDate))

# à effacer quand code fini (redondant avec partie préprocessing)
dims_choice = "2:30"
```

<!--*************************************************************************-->
<br><br><br>
<!--*************************************************************************-->

# .Mise en forme des données en Objet Seurat

```{r, Create the Object, message=F, warning=F}

counts <- Seurat::Read10X_h5(filename = paste0(dir_input, "filtered_peak_bc_matrix.h5"))

# Sequencing information
metadata <- read.csv(
  file = paste0(dir_input, "singlecell.csv"),
  header = TRUE,
  row.names = 1
)

chrom_assay <- CreateChromatinAssay(
  counts = counts,
  sep = c(":", "-"),
  genome = 'hg38',
  fragments = paste0(dir_input, "fragments.tsv.gz"), # tous les reads/cell, où ils tombent et combien de fois ils ont été trouvés (même non assignés)
  min.cells = 100,
  min.features = 200
)

seurat_obj <- CreateSeuratObject(
  counts = chrom_assay,
  assay = "peaks",
  meta.data = metadata)

# Check for the assays informations
seurat_obj[['peaks']]

# Remove unused objects
rm(chrom_assay, counts, metadata)
```

```{r, Basic functions for information access}

###############
## METADATA ##
###############

# Cells(x = seurat_obj) # Cell name
# rownames(x = seurat_obj) # Peak name
# ncol(x = seurat_obj) # nb of cell
# nrow(x = seurat_obj) # nb of peaks

# Set identity classes
Idents(object = seurat_obj) <- "MP"

##################
## Downsampling ##
##################

# Downsample the number of cells per identity class
# Creation of a downsampled object to test and develop the code
# seurat_obj_dwn = subset(x = seurat_obj, downsample = 100)
# Do we work on all seurat_object or downsampled one ?
# seurat_obj = seurat_obj_dwn
# rm(seurat_obj_dwn)

##########################################
## cell embedding and feature loadings ##
########################################

# Return all reductions computed for each assay
# seurat_obj@reductions

# Info about one specific reduction (here we test lsi reduction)
# seurat_obj@reductions$lsi
# seurat_obj[["lsi"]]

## Access to data generated by the  dimension reduction

# Cell embeddings
# head(Embeddings(seurat_obj, reduction = "lsi"))[,1:3]

# Feature loadings
# head(Loadings(object = seurat_obj, reduction = "lsi"))[,1:3]

########################
## expression matrix ##
#######################

# Retrieve or set data in an expression matrix ('counts', 'data', and 'scale.data')
# GetAssayData(object = seurat_obj, slot = "counts") # Access the count matrix (peaks/cell)

```

```{r, Clean Seurat Grange from non standard chromosome names}

# pose des problèmes avec le clustering ! 
# quand on fait cela, on n'a plus le même nombre de peaks entre le grange et le chromatinAssay
# on obtient l'erreur subscript is a logical vector with out-of-bounds TRUE values


# https://www.biostars.org/p/9466838/
# https://kasperdanielhansen.github.io/genbioconductor/html/GenomicRanges_seqinfo.html
# https://web.mit.edu/~r/current/arch/i386_linux26/lib/R/library/GenomeInfoDb/html/seqinfo.html

# Visualize grange object and chromosomes seqnames before cleaning
# table(seurat_obj@assays$peaks@ranges@seqnames)
# seurat_obj@assays$peaks@ranges
# 
# # Keep only standard chromosomes names (1-22, X, Y, M) : option coarse, peaks with non standard chromosome name are remove
# seurat_obj@assays$peaks@ranges = keepStandardChromosomes(seurat_obj@assays$peaks@ranges, pruning.mode = "coarse")
# test = seurat_obj
# test = keepStandardChromosomes(seurat_obj)

# # Visualize grange object and chromosomes seqnames after cleaning
# table(seurat_obj@assays$peaks@ranges@seqnames)
# seurat_obj@assays$peaks@ranges

```

Passage d'un Grange à 165 599 features à 165 559 features (=peaks) => 40 peaks ont été enlevés (très peu donc pas de biais)

```{r, Add annotation file}

# Needed for TSS Enrichment (quality control function)
# Extract gene annotations from EnsDb and attach it to the seurat object (all the BDD annotations)
# This will allow downstream function to extract gene information directly from the object instead of remote request to a server
annotations <- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v86)

# change to UCSC style
seqlevelsStyle(annotations) = "UCSC"

# add the gene information to the seurat object
Annotation(seurat_obj) = annotations

# Extract informations from BDD annotations
table(mcols(Annotation(seurat_obj))$type)

```

```{r Add metadata in Grange (peak name and annotation), message=FALSE, warning=F}

# Ajout du nom du peak pour avoir une correspondance avec la matrix count de chromatin assay
mcols(seurat_obj@assays$peaks@ranges)$peaks_name = paste0(seurat_obj@assays$peaks@ranges@seqnames, "-", seurat_obj@assays$peaks@ranges@ranges)

# Load Annotation file and extract annotations levels
all_annotations = readRDS(paste0(dir_git, "/data/Annotation_TSS_pm1kb_int_ex_53utr_ctcf_cpg_woThisto_FANTOM5_prom_gr.rds"))
annotations_types = levels(factor(all_annotations$annotation))

# First a matrix is created filled with FALSE and added to the Grange
metadata = matrix(FALSE, ncol = length(annotations_types), nrow = length(seurat_obj@assays$peaks@ranges))
colnames(metadata) = annotations_types
mcols(seurat_obj@assays$peaks@ranges) = metadata 

# for each of the annotations types an overlap is calculated and used to assigned the peak as TRUE when overlapping with the annotation
for (i in 1:ncol(metadata)){
  sub_annot = all_annotations[all_annotations$annotation == annotations_types[i]]
  overlaps = findOverlaps(seurat_obj@assays$peaks@ranges, sub_annot)
  mcols(seurat_obj@assays$peaks@ranges)[queryHits(overlaps),i] = TRUE
}

colnames(mcols(seurat_obj@assays$peaks@ranges)) = case_when(colnames(mcols(seurat_obj@assays$peaks@ranges)) == "3' UTR" ~ "UTR3P",
                                colnames(mcols(seurat_obj@assays$peaks@ranges)) == "5' UTR" ~ "UTR5P",
                                colnames(mcols(seurat_obj@assays$peaks@ranges)) == "CpG Island" ~ "CpG",
                                colnames(mcols(seurat_obj@assays$peaks@ranges)) == "CTCF" ~ "CTCF",
                                colnames(mcols(seurat_obj@assays$peaks@ranges)) == "EXON" ~ "Exons",
                                colnames(mcols(seurat_obj@assays$peaks@ranges)) == "FANTOM5_promoter" ~ "FANTOM5_promoter",
                                colnames(mcols(seurat_obj@assays$peaks@ranges)) == "INTRON" ~ "Introns",
                                colnames(mcols(seurat_obj@assays$peaks@ranges)) == "Promoter_+-1000"  ~ "TSS_mp1kb")

mcols(seurat_obj@assays$peaks@ranges) = as_tibble(mcols(seurat_obj@assays$peaks@ranges)) %>%
  dplyr::mutate(Intergenic = ifelse(UTR3P == FALSE & 
                                    UTR5P == FALSE & 
                                    Exons == FALSE & 
                                    Introns == FALSE & 
                                    FANTOM5_promoter == FALSE & 
                                    TSS_mp1kb == FALSE, TRUE, FALSE)) %>%
  dplyr::mutate(CpG_Intergenic = ifelse(Intergenic == TRUE & CpG == TRUE, TRUE, FALSE)) %>%
  dplyr::mutate(CpG_Intergenic = ifelse(Intergenic == TRUE & CpG == TRUE, TRUE, FALSE)) %>%
  dplyr::mutate(CTCF_Intergenic = ifelse(Intergenic == TRUE & CTCF == TRUE, TRUE, FALSE)) %>%
  dplyr::mutate(CTCF_in_intron = ifelse(Introns == TRUE & CTCF == TRUE, TRUE, FALSE)) %>%
  dplyr::mutate(CTCF_in_exon = ifelse(Exons == TRUE & CTCF == TRUE, TRUE, FALSE))

# Visualize grange with new metadata columns
seurat_obj@assays$peaks@ranges

# Clean working space
rm(annotations, all_annotations, sub_annot, metadata, annotations_types, overlaps, i)

```

```{r, Save FACULTATIF}
saveRDS(object = seurat_obj, file = paste0(dir_output, currentDate, "/seurat_obj_annot.rds")) 
```


<!--*************************************************************************-->
<br><br><br>
<!--*************************************************************************-->

# .Contrôle qualité des données de l'échantillon

```{r, TSS Enrichment, results = 'hold', fig.width=6, fig.height=4}

# compute TSS enrichment score per cell and add it to meta.data in TSS.enrichment column
seurat_obj <- TSSEnrichment(object = seurat_obj, fast = FALSE)

# Compute a new column in meta.data, based on TSS.enrichment column
seurat_obj$high.tss <- ifelse(seurat_obj$TSS.enrichment > 2, 'High', 'Low')

# Plot based on TSS.enrichment, and group according high.tss column
plot_quality_tss = TSSPlot(seurat_obj, group.by = 'high.tss') + NoLegend()
plot_quality_tss

# Save and clean working space
ggsave(plot = plot_quality_tss, filename = paste0(dir_output, currentDate, "/plot_quality_tss.png"))
rm(plot_quality_tss)
```

```{r, Nucleosome Signal, results = 'hold', fig.width=12, fig.height=4}

# Compute nucleosome signal score per cell and add it to meta.data in nucleosome_signal column
seurat_obj <- NucleosomeSignal(object = seurat_obj)

# Compute a new column in meta.data, based on nucleosome_signal column
seurat_obj$nucleosome_group <- ifelse(seurat_obj$nucleosome_signal > 4, 'NS > 4', 'NS < 4')

# Plot based on nucleosome_signal, and group according nucleosome_group column
plot_quality_nucl = FragmentHistogram(object = seurat_obj, group.by = 'nucleosome_group')
plot_quality_nucl

# Save and clean working space
ggsave(plot = plot_quality_nucl, filename = paste0(dir_output, currentDate, "/plot_quality_nucl.png"), width = 12)
rm(plot_quality_nucl)

```

```{r, QC plots, results = 'hold', fig.width=16, fig.height=6}

# compute percentage of reads in peaks for each cells
seurat_obj$pct_reads_in_peaks <- seurat_obj$peak_region_fragments / seurat_obj$passed_filters * 100
# peak_region_fragments of a cell = number of reads assigned to the peak studied 

# Violin plots for QC
plot_quality_vln = VlnPlot(
  object = seurat_obj,
  features = c('pct_reads_in_peaks', 'peak_region_fragments', 'TSS.enrichment', 'nucleosome_signal'),
  pt.size = 0.1,
  ncol = 5
)
plot_quality_vln

# Save and clean working space
ggsave(plot = plot_quality_vln, filename = paste0(dir_output, currentDate, "/plot_quality_vln.png"), width = 16, height = 6)
rm(plot_quality_vln)

```

```{r, Save FACULTATIF}
# saveRDS(object = seurat_obj, file = paste0(dir_output, currentDate, "/seurat_obj_dwn_qc.rds")) 
saveRDS(object = seurat_obj, file = paste0(dir_output, currentDate, "/seurat_obj_qc.rds")) 
```

<!--*************************************************************************-->
<br><br><br>
<!--*************************************************************************-->

# .Préproccessing des données : normalisation et réductions de dimensions

```{r, LOAD FACULTATIF}
# seurat_obj = readRDS(file = paste0(dir_output, currentDate, "/seurat_obj_dwn_qc.rds")) 
seurat_obj = readRDS(file = paste0(dir_output, currentDate, "/seurat_obj_qc.rds")) 
```

```{r, Normalization, message=F, warning=F, results = 'hold', fig.width=16, fig.height=6}

# Normalization: term frequency-inverse document frequency (TF-IDF) normalization. 
# Two-step normalization procedure, that both normalizes across cells to correct for differences in cellular sequencing depth, and across peaks to give higher values to more rare peaks.
seurat_obj <- RunTFIDF(seurat_obj)

# Choose to use only the top n% of features (peaks) for dimensional reduction
# Can also remove features present in less than n cells
# Set qXX to only select the top 90% features (peaks)
# Features used for dimensional reduction are automatically set as VariableFeatures() by this function.
seurat_obj <- FindTopFeatures(seurat_obj, min.cutoff = 'q10') # Drop the 10 lowest %

# Dimension reduction: singular value decomposition (SVD) on the TD-IDF matrix
# It automatically uses the features (peaks) selected above. 
# This returns a reduced dimension representation of the object 
# (You can think of this as analogous to the output of PCA).
seurat_obj <- RunSVD(seurat_obj)

## ATTENTION : The combined steps of TF-IDF followed by SVD are known as latent semantic indexing (LSI)
# The 1st LSI component often captures sequencing depth (technical variation) rather than biological variation
# If this is the case (< - 0.7 or > 0.7), then discard it for further analysis
plot_dim_depth = DepthCor(object = seurat_obj, assay ="peaks", reduction = "lsi", n = NULL) + 
  geom_hline(yintercept = -0.7, linetype = "dashed", color = "red") +
  geom_hline(yintercept = + 0.7, linetype = "dashed", color = "red")

# We play on ylim to manually remove lsi1 and visualize the elbow
plot_dim_elb = ElbowPlot(object = seurat_obj, ndims = 50, reduction = "lsi") + 
    ylim(0.2, 3) +
    theme(plot.background = element_rect(fill = "white"))

plot_dim_depth | plot_dim_elb

# Choice of working dimensions
dims_choice = c(2:30)
dims_choice_char = "2-30"

# Save and clean working directory
ggsave(plot = plot_dim_depth | plot_dim_elb, filename = paste0(dir_output, currentDate, "/plot_preprocess_dim.png"), width = 18, height = 6)
rm(plot_dim_elb, plot_dim_depth)
```
fichier downsampled : Coude observé entre 5 et 10 dimensions. pour la suite, on travaille avec 10 dimensions. 
All data set : coude observé entre 20 et 30 dimensions, on choisit d'utiliser 30 dimensions.
Quand doute sur le nombre de dims à conserver : il vaut mieux en prendre plus que pas assez

```{r, Umap with diff resolution, results = 'hold', fig.width=16, fig.height=10}

# Compute another reduction (commonly used for RNAseq) : UMAP
  ## Of note, usually UMAP is based on PCA dimension reduction, but here it's on lsi
  ## Dump the first dimension according to the graph above
seurat_obj <- RunUMAP(object = seurat_obj, reduction = 'lsi', dims = dims_choice)
# => Now another reduction has been added to seurat_obj@reduction : "umap"

# Constructing the K-nearest neighbor (KNN) graph (by default)
# Edges drawn between cells with similar gene expression patterns. 
# Then, it attempts to partition this graph into highly interconnected ‘quasi-cliques’ or ‘communities’.
seurat_obj <- FindNeighbors(object = seurat_obj, reduction = 'lsi', dims = dims_choice)
# => This function adds a "graph" named peaks_snn in seurat_obj@graphs

# Based on the current default assay
## Resolution = 0.8
## Algorithm = 1 = Louvain
seurat_obj <- FindClusters(object = seurat_obj, algorithm = 3)
# => This function adds 2 new columns to meta.data : seurat_clusters AND peaks_snn_res.0.8. There are equivalent
# => If the name of algorithm is changed, then this 2 columns are replaced and a little bit different from previously

# Try different resolution argument that sets the “granularity” of the downstream clustering
for (res in c(0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 0.8, 1)) {
    seurat_obj <- FindClusters(
      object = seurat_obj, 
      graph.name = "peaks_snn", 
      resolution = res, 
      algorithm = 3)
}

# => Recalculate the clusters for different resolution and store the results in new columns in meta.data
# names(seurat_obj[[]]) # to see the columns added
plot_resolution = plot_grid(
  ncol = 3, 
  nrow = 3,
  DimPlot(seurat_obj, reduction = "umap", group.by = "peaks_snn_res.0.01") + ggtitle("Resolution_0.01"),
  DimPlot(seurat_obj, reduction = "umap", group.by = "peaks_snn_res.0.02") + ggtitle("Resolution_0.02"),
  DimPlot(seurat_obj, reduction = "umap", group.by = "peaks_snn_res.0.05") + ggtitle("Resolution_0.05"),
  DimPlot(seurat_obj, reduction = "umap", group.by = "peaks_snn_res.0.1") + ggtitle("Resolution_0.1"),
  DimPlot(seurat_obj, reduction = "umap", group.by = "peaks_snn_res.0.2") + ggtitle("Resolution_0.2"),
  DimPlot(seurat_obj, reduction = "umap", group.by = "peaks_snn_res.0.5") + ggtitle("Resolution_0.5"),
  DimPlot(seurat_obj, reduction = "umap", group.by = "peaks_snn_res.0.8") + ggtitle("Resolution_0.8"),
  DimPlot(seurat_obj, reduction = "umap", group.by = "peaks_snn_res.1") + ggtitle("Resolution_1"))
plot_resolution

# Save and clean working space
ggsave(plot = plot_resolution, 
       filename = paste0(dir_output, currentDate, "/plot_dim", dims_choice_char, "_resolution.png"), 
       width = 18, height = 10)
rm(plot_resolution, res)
```

=> pk algo = 3 ???
Commentaire : résolution au dessus de 0.05 ne sépare pas bien les clusters. On choisit des valeurs en dessous. => se renseigner pour voir si c'est mieux de prendre la plus élevée possible ou pas 

```{r, Umap with diff kmean, results = 'hold', fig.width=16, fig.height=8}

# Same approach but compare with k means method

for (k in c(2, 3, 4, 5, 10)) {
     seurat_obj@meta.data[, paste0("kmeans_", k)] <- kmeans(x = seurat_obj@reductions[["lsi"]]@cell.embeddings, centers = k, nstart = 100)$cluster
 }
 
plot_kmean = plot_grid(
   ncol = 3,
    DimPlot(seurat_obj, reduction = "umap", group.by = "kmeans_2") + ggtitle("kmeans_2"), 
    DimPlot(seurat_obj, reduction = "umap", group.by = "kmeans_3") + ggtitle("kmeans_3"),
    DimPlot(seurat_obj, reduction = "umap", group.by = "kmeans_4") + ggtitle("kmeans_4"),
    DimPlot(seurat_obj, reduction = "umap", group.by = "kmeans_5") + ggtitle("kmeans_5"), 
    DimPlot(seurat_obj, reduction = "umap", group.by = "kmeans_10") + ggtitle("kmeans_10"))
plot_kmean

# Save plot and clean working space
ggsave(plot = plot_kmean, 
       filename = paste0(dir_output, currentDate, "/plot_dim", dims_choice_char, "_kmean.png"), 
       width = 18, height = 8)
rm(plot_kmean, k)

```

```{r, Save FACULTATIF}
# saveRDS(object = seurat_obj, file = paste0(dir_output, currentDate, "/seurat_obj_dwn_preprocess_dim", dims_choice_char,".rds")) 
saveRDS(object = seurat_obj, file = paste0(dir_output, currentDate, "/seurat_obj_preprocess_dim", dims_choice_char,".rds")) 
```


<!--*************************************************************************-->
<br><br><br>
<!--*************************************************************************-->



# .Association des peaks à l'activité du gène le plus proche

```{r, Load FACULTATIF}
# seurat_obj = readRDS(file = paste0(dir_output, currentDate, "/seurat_obj_dwn_preprocess_dim2-10.rds")) 
seurat_obj = readRDS(file = paste0(dir_output, currentDate, "/seurat_obj_preprocess_dim2-30.rds")) 
```

```{r, Gene activity matrix}

# Transfo les données ATAC en équivalent RNA : convertit le nombre de reads comme si c'était des UMI

# Create a gene activity matrix based on the number of reads mapping to each in gene (gene body +2kb upstream)
gene.activities <- GeneActivity(seurat_obj)

# add the gene activity matrix to the Seurat object as a new assay  
seurat_obj[['RNA']] <- CreateAssayObject(counts = gene.activities)

# The count normalizes it
seurat_obj <- NormalizeData(
  object = seurat_obj,
  assay = 'RNA',
  normalization.method = 'LogNormalize',
  scale.factor = median(seurat_obj$nCount_RNA)
)
# => Adds normalized data to seurat_obj[['RNA]]@data slot

```

```{r, Gene activity plot, results = 'hold', fig.width=16, fig.height=12}

DefaultAssay(seurat_obj) <- 'RNA'

seurat_obj <- FindVariableFeatures(object = seurat_obj, assay = 'RNA', nfeatures = 100)
# Adds a slot@var.features

# On garde la reduction PCA de ATACseq donc les mêmes clusters
# On "colle" par dessus l'info des gènes exprimés
# Possibilité de regarder un gène particulier !
plot_varfeature = FeaturePlot(
  object = seurat_obj,
  features = seurat_obj[['RNA']]@var.features[1:10],
  pt.size = 0.1,
  max.cutoff = 'q95',
  ncol = 3
)
plot_varfeature

# Save plot and clean working space
ggsave(plot = plot_varfeature, 
       filename = paste0(dir_output, currentDate, "/plot_dim", dims_choice_char, "_varfeature.png"), 
       width = 18, height = 16)
rm(gene.activities, plot_varfeature)

```
Dig if valuable to dig in this direction, using gene activity matrix ... Rudi ?

```{r, Save FACULTATIF}
# saveRDS(object = seurat_obj, file = paste0(dir_output, currentDate, "/seurat_obj_dwn_geneact_dim", dims_choice_char, ".rds")) 
saveRDS(object = seurat_obj, file = paste0(dir_output, currentDate, "/seurat_obj_geneact_dim", dims_choice_char, ".rds")) 
```


<!--*************************************************************************-->
<br><br><br>
<!--*************************************************************************-->



# .Investigation sur les clusters obtenus 

```{r, Load FACULTATIF}
# seurat_obj = readRDS(file = paste0(dir_output, currentDate, "/seurat_obj_dwn_geneact_dim2-10.rds")) 
seurat_obj = readRDS(file = paste0(dir_output, currentDate, "/seurat_obj_geneact_dim2-30.rds")) 
```

```{r, Change DefaultAssay and choose resolution}

# Change back to working with peaks instead of gene activities
DefaultAssay(seurat_obj) <- 'peaks'

# Choose working resolution
res = "res.0.05"
meta_col = paste0("peaks_snn_", res)
Idents(seurat_obj) = (seurat_obj@meta.data)[,meta_col]

```


FONCTIONNEL :  
- si ça a disparu, alors faire le SetAssayData.chromatinassay (new.data = ranges.keep) avec ranges.keep = rownames(seurat_clust)


```{r, Peaks distribution per cell across clusters - tabs creation}

# https://github.com/satijalab/seurat/issues/1053

# Create dataframe with summary of peaks per cell and/or per annotation
tab_distripeaks_clust = data.frame()
tab_bulkpeaks_clust = data.frame()
  
for ( i in 1:length(levels((seurat_obj@meta.data)[,meta_col])) ) {
  
  # Extract cluster number
  clust = levels((seurat_obj@meta.data)[,meta_col])[i]
  print(paste("Peaks extraction for clust ", clust))
  # Create subset of seurat object with cells from clust x
  expr = FetchData(object = seurat_obj, vars = meta_col)
  seurat_clust = seurat_obj[, which(expr == clust)]                 # ligne qui prend du temps
  # Check if the subset was correctly done
  print(table((seurat_clust@meta.data)[,meta_col])) 
  
  # Extract peak count matrix of clust x from general seurat object
  tab_clust = as.data.frame(GetAssayData(seurat_clust, slot = "data"))          # ligne qui prend du temps
  # Transform count into logical
  tab_clust = tab_clust %>% mutate_all(as.logical)
  
  # Extract peaks_name according to genomic annotation
  peaks_name_list = list(
    total_peaks = seurat_clust@assays$peaks@ranges$peaks_name,
    peaks_FANTOM5_promoter = (seurat_clust@assays$peaks@ranges[seurat_clust@assays$peaks@ranges$FANTOM5_promoter == TRUE])$peaks_name,
    peaks_UTR3P = (seurat_clust@assays$peaks@ranges[seurat_clust@assays$peaks@ranges$UTR3P == TRUE])$peaks_name,
    peaks_UTR5P = (seurat_clust@assays$peaks@ranges[seurat_clust@assays$peaks@ranges$UTR5P == TRUE])$peaks_name,
    peaks_CpG = (seurat_clust@assays$peaks@ranges[seurat_clust@assays$peaks@ranges$CpG == TRUE])$peaks_name,
    peaks_CTCF = (seurat_clust@assays$peaks@ranges[seurat_clust@assays$peaks@ranges$CTCF == TRUE])$peaks_name,
    peaks_Exons = (seurat_clust@assays$peaks@ranges[seurat_clust@assays$peaks@ranges$Exons == TRUE])$peaks_name,
    peaks_Introns = (seurat_clust@assays$peaks@ranges[seurat_clust@assays$peaks@ranges$Introns == TRUE])$peaks_name,
    peaks_TSS_mp1kb = (seurat_clust@assays$peaks@ranges[seurat_clust@assays$peaks@ranges$TSS_mp1kb == TRUE])$peaks_name,
    peaks_Intergenic = (seurat_clust@assays$peaks@ranges[seurat_clust@assays$peaks@ranges$Intergenic == TRUE])$peaks_name,
    peaks_CpG_Intergenic = (seurat_clust@assays$peaks@ranges[seurat_clust@assays$peaks@ranges$CpG_Intergenic == TRUE])$peaks_name,
    peaks_CTCF_Intergenic = (seurat_clust@assays$peaks@ranges[seurat_clust@assays$peaks@ranges$CTCF_Intergenic == TRUE])$peaks_name,
    peaks_CTCF_in_intron = (seurat_clust@assays$peaks@ranges[seurat_clust@assays$peaks@ranges$CTCF_in_intron == TRUE])$peaks_name,
    peaks_CTCF_in_exon = (seurat_clust@assays$peaks@ranges[seurat_clust@assays$peaks@ranges$CTCF_in_exon == TRUE])$peaks_name
    )

  # Calculate number of peaks total per annotation and per cell per annotation
  temp_distripeaks = lapply(peaks_name_list, function(x) {
    tab_filtered = tab_clust %>% dplyr::filter(row.names(tab_clust) %in% unlist(x))
    tab_calc = data.frame(colSums(tab_filtered)) 
    tab_calc = tab_calc %>% tibble::rownames_to_column(var = "cell")})
  temp_distripeaks = bind_rows(temp_distripeaks, .id = "peaks_category") %>% dplyr::mutate(clust = clust)
  colnames(temp_distripeaks) = c("peaks_category", "cell", "total_nbpeaks_percell", "clust")
  
  temp_bulkpeaks = data_frame(annotation = names(peaks_name_list), total_nbpeaks = as.numeric(lapply(peaks_name_list, length))) %>% dplyr::mutate(clust = clust, .before = "total_nbpeaks")
  
  # Bind in general tab
  tab_bulkpeaks_clust = rbind(tab_bulkpeaks_clust, temp_bulkpeaks)
  tab_distripeaks_clust = rbind(tab_distripeaks_clust, temp_distripeaks)
  
}

# Add statistical information
tab_distripeaks_stat = tab_distripeaks_clust %>%
  dplyr::group_by(clust, peaks_category) %>%
  dplyr::mutate(nbcells_clust = n(),
                median_nbpeaks_percell = median(total_nbpeaks),
                mean_nbpeaks_percell = round(mean(total_nbpeaks)),
                max_nbpeaks_percell = max(total_nbpeaks),
                min_nbpeaks_percell = min(total_nbpeaks),
                var_nbpeaks_percell = round(sd(total_nbpeaks))) %>%
  dplyr::ungroup() %>%
  dplyr::select(peaks_category, clust, nbcells_clust, median_nbpeaks_percell, mean_nbpeaks_percell, max_nbpeaks_percell, min_nbpeaks_percell, var_nbpeaks_percell) %>%
  dplyr::distinct()

# Save dataframes and clean working space
write_csv2(tab_bulkpeaks_clust, file = paste0(dir_output, currentDate, "/tab_dim", dims_choice_char, "_", res, "_bulkpeaks.csv"))
write_csv2(tab_distripeaks_clust, file = paste0(dir_output, currentDate, "/tab_dim", dims_choice_char, "_", res, "_distripeaks.csv"))
write_csv2(tab_distripeaks_stat, file = paste0(dir_output, currentDate, "/tab_dim", dims_choice_char, "_", res, "_distripeaks_stat.csv"))
rm(temp_bulkpeaks, temp_distripeaks, peaks_name_list, clust, seurat_clust, i, expr, tab_clust)

```

```{r, Peaks distribution per cell across clusters - tabs visualization}

# load files (facultatif)
# tab_bulkpeaks_clust = read_csv2(paste0(dir_output, currentDate, "/tab_dim", dims_choice_char, "_", res, "_bulkpeaks.csv"))
# tab_distripeaks_clust = read_csv2(paste0(dir_output, currentDate, "/tab_dim", dims_choice_char, "_", res, "_distripeaks.csv"))
# tab_distripeaks_stat = read_csv2(paste0(dir_output, currentDate, "/tab_dim", dims_choice_char, "_", res, "_distripeaks_stat.csv"))

# Visualize output tab
tab_distripeaks_clust %>% 
  kable(caption = res) %>% 
  kable_styling()  %>%
  scroll_box(height = "250px", width = "100%")

tab_distripeaks_stat %>% 
  kable(caption = res) %>% 
  kable_styling()  %>%
  scroll_box(height = "250px", width = "100%")

tab_bulkpeaks_clust %>%
  kable(caption = res) %>% 
  kable_styling() %>%
  scroll_box(height = "250px", width = "100%")

```

```{r, Peaks distribution per cell across clusters - plots, results = 'hold', fig.width=20, fig.height=12}
  
# Histogram : nbpeaks per annotation per cluster
plot_bulkpeak = ggplot(tab_bulkpeaks_clust, aes(x=annotation, y=total_nbpeaks, fill=clust)) +
  geom_bar(stat="identity", position=position_dodge()) +
  ylab(label = "TOTAL PEAK NUMBER IN CLUSTER") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
        axis.title.x = element_blank())
plot_bulkpeak

# Distribution : nbpeaks per cell per annotation 
tab_plot  = full_join(tab_distripeaks_clust, tab_distripeaks_stat, by = c("peaks_category", "clust"))
plot_distripeak = ggplot(tab_plot, aes(x=total_nbpeaks, fill=clust)) +
  geom_histogram(bins = 50, color = "black", alpha = 0.5) +
  geom_vline(aes(xintercept = median_nbpeaks_percell, col = clust), linetype = "dashed", size = 1) +
  ggtitle(label = paste0("Distribution of peaks' number per cell according to cluster (with median) - ", res, " / ATTENTION : different scales !")) +
  ylab(label = "CELL COUNT") +
  facet_wrap(facets = .~peaks_category, scales = "free") +
  theme(axis.title.x = element_blank())
plot_distripeak

# Save objects and clean working space
ggsave(plot = plot_bulkpeak,
       filename = paste0(dir_output, currentDate, "/plot_dim", dims_choice_char, "_", res, "_hist_annot_clust_bulk.png"),
       width = 14, height = 6)
ggsave(plot = plot_distripeak,
       filename = paste0(dir_output, currentDate, "/plot_dim", dims_choice_char, "_", res, "_distri_annot_clust_sc.png"),
       width = 14, height = 6)
rm(tab_bulkpeaks_clust, tab_distripeaks_clust, tab_distripeaks_stat, tab_plot, plot_distripeak, plot_bulkpeak, res, meta_col)

```

EN COURS : 

```{r, TSS Peaks distribution accross clusters, results = 'hold', fig.width=14, fig.height=6}

# tab_clust = as.data.frame(GetAssayData(seurat_clust, slot = "data")) # Le cluster 0 contient 1971 cellules (en res 0.2)
# tab_clust = tab_clust[rowSums(tab_clust[])>0, ] # on enlève les peaks qui ne sont pas du tout détectés dans aucune cellule (tous les peaks sont détectés)
# list_peaks = data.frame(peak = rownames(tab_clust)) # pas très utile car tous les peaks sont détectés

# https://www.biostars.org/p/108080/

# attention : quand on fait un subset de l'objet seurat, le grange annotation n'est pas modifié 
# # Extract annotations name from BDD grange store in seurat object
# grange_annot = Annotation(seurat_clust) # 3 021 151 ranges (= peaks)
# # idem que si on faisait Annotation(seurat_obj)
# levels(mcols(grange_annot)$type) # 703 128 cds, 1 101 668 exon, 940 523 gap, 275 832 utr
# table(grange_annot$type) # on veut extraire les peaks correspondant à la liste des 703128 peaks qui tombent dans cds
# # !!! on a ici tous les peaks de la BDD et pas ceux qui correspondent à l'échantillon !!! 
# # tab_annot = data.frame(seqnames = grange_annot@seqnames, 
# #                   ranges = grange_annot@ranges, 
# #                   type = grange_annot$type, 
# #                   gene_name = grange_annot$gene_name)
# # tab_annot = tab_annot %>% 
# #   dplyr::mutate(peak = paste0(seqnames, "-", ranges.start, "-", ranges.end)) %>%
# #   dplyr::select(peak, type, gene_name)
# # # mettre en relation le nom de nos peaks et leurs annotations
# test = full_join(list_peaks, tab_annot, by = "peak") # ne fonctionne pas car les peaks ne correspondent pas exactement il faut prendre les overlaps 

# création d'un grange avec seulement les peaks voulus 
library(plyranges) # https://support.bioconductor.org/p/133546/
grange_cds = grange %>% plyranges::filter(type == "cds") # grange contenant seulement les 703128 peaks cds
table(grange_cds$type)

# grange de Annotation => 3 021 151 ranges
# grange_cds => 703 128 ranges
# seurat_clust@assays$peaks@ranges
# grange de seurat_clust => 165 599 ranges ?

# https://www.biostars.org/p/473162/ 



```

```{r, Peaks distribution accross clusters in annotations}
# pour chacun des deux clusters, faire la même distribution mais pour chaque élément/annotation génomique et faire les histogrammes comme pour le bulk
```

```{r, Cluster gene specific }

# sortir la liste de tous les gènes qui ont un peak dans le clust0, dans le clust1, enlever l'intersection et regarder ce qui n'est pas en commun :
  # - sous sampling que les peaks qui tombent dans TSS (refaire FindMarkers ?)
  # - utiliser closest feature sur tous ces peaks par cluster
  # - faire l'exclusion pour sortir la liste particulière de chaque cluster
  # - GO sur les deux listes

#################################
# sur touts les peaks 
#################################

meta_col = paste0("peaks_snn_res.0.2")

# Subset of seurat object to keep only cells from clust0
clust = "0"
expr = FetchData(object = seurat_obj, vars = meta_col)
seurat_clust0 = seurat_obj[, which(x = (expr == clust))]
# seurat_clust0@assays$peaks
# print(table((seurat_clust0@meta.data)[,meta_col])) 
# granges(seurat_clust0)
# Identify closest genes from peaks
clust0_gene <- ClosestFeature(seurat_clust0, regions = granges(seurat_clust0)) 
clust0_gene_list = as.vector(clust0_gene$gene_name)
# tous les peaks sont présents dans les deux clusters mais pas en même proportion ?

# Subset of seurat object to keep only cells from clust1
clust = "1"
expr = FetchData(object = seurat_obj, vars = meta_col)
seurat_clust1 = seurat_obj[, which(x = (expr == clust))]
# Identify closest genes from peaks
clust1_gene <- ClosestFeature(seurat_clust1, regions = granges(seurat_clust1))
clust1_gene_list = as.vector(clust1_gene$gene_name)

# pb : tous les gènes sont représentés dans les deux clusters, il faut s'intéresser aux proportions d'accessibilité
table(clust0_gene_list == clust1_gene_list)


################################################################################
# sur les 200 peaks les plus représentés (le plus de cellules qui le présentent)
################################################################################

tab_clust0 = as.data.frame(GetAssayData(seurat_clust0, slot = "data")) %>% mutate_all(as.logical)
tab_peak_clust0 = data.frame(nbcells = rowSums(tab_clust0)) %>% 
  tibble::rownames_to_column(var = "peak") %>%
  dplyr::arrange(desc(nbcells))
tab_top200 = head(tab_peak_clust0, 200)



```

```{r AddChromatinModule}

# Trouver des listes de gènes qui  nous intéressent, genre "souche, cellule T" ou bien même encore plus simplement les listes des gènes de chaque cluster de CALISTA (!)
# Choper les peaks qui tombe dans les TSS de ces gènes là
# Donner ces listes de gènes à la fonction AddChromatinModule
# Espèrer que le gros cluster corresponde au cluster 2 de Calista et que le petit au cluster 3/4/5
# Ou alors  espèrer que le gros cluster ait une signature plus "souche" que le cluster petit
```


=> faire un downsampling


FONCTIONNEL MAIS A RETRAVAILLER / COMPLETER 

```{r, Find Differential Accessibility}

# Extract cells from clust0 and clust1
# clust0_cells = names(seurat_obj$peaks_snn_res.0.05[which(seurat_obj$peaks_snn_res.0.05 == 0)])
# nbcells_clust0 = length(clust0_cells)
# clust1_cells = names(seurat_obj$peaks_snn_res.0.05[which(seurat_obj$peaks_snn_res.0.05 == 1)])
# nbcells_clust1 = length(clust1_cells)

# Compare clusters
da_peaks <- FindMarkers(
  object = seurat_obj,
  ident.1 = 0,
  ident.2 = 1,
  min.pct = 0.05,  # au minimum le peak doit être partagé par 5% de la pop
  test.use = 'LR',
  latent.vars = 'peak_region_fragments',
  verbose = TRUE
)
# ident.1 : identity class to define markers for 
# ident.2 : a second identity class for comparison
# avg_logFC: Positive values indicate that the gene is more highly expressed in the first group
# si foldchange > 0.5, alors cells de ident1 plus accessibles que celles de ident2
# si foldchange < -0.5, alors cells de ident1 moins accessibles que celles de ident2
# pct.1: The percentage of cells where the gene is detected in the first group
# pct.2: The percentage of cells where the gene is detected in the second group
head(da_peaks)

# Extract peaks with log2FC > 0.5
DA_openPeaks <- rownames(da_peaks[da_peaks$avg_log2FC > 0.5, ])
# Extract peaks with log2FC < - 0.5
DA_closePeaks <- rownames(da_peaks[da_peaks$avg_log2FC < -0.5, ])

# pb : que des fold-change négatif : que des peaks qui se ferment dans le petit groupes ??? erreur ou pas DA_1 = empty
# les deux sont empty quand on choisit une résolution de 0.1 et 0.2
```

à vérifier : est-ce que les foldchange conservés sont seulement ceux qui ont une p-value importante (statistiquement important) ? Voir les paramètres de base de la fonction. car dans la vignette pas de threshold appliqué. 
Autres résolutions => les clusters sont pas les mêmes, attention à ident1 et ident2

```{r Identifying peaks with high fold change}

# Place peaks on genome and determine the closest gene
# on obtient un tableau => vérifier si on a l'info de la fiabilité de l'attribution des gènes dans les peaks
DA_closePeaks_gene <- ClosestFeature(seurat_obj, regions = DA_closePeaks)
head(DA_closePeaks_gene)

# DA_openPeaks_gene <- ClosestFeature(seurat_obj, regions = DA_openPeaks)
# head(DA_openPeaks_gene)

```

```{r Gene Ontology}

# Sur les peaks qui sont plus fermés : 

# Code issu de l'analyse MARS ATAC = ne pas modifier
name_correspondace = bitr(DA_closePeaks_gene$gene_id, fromType = "ENSEMBL", toType = "ENTREZID", OrgDb = "org.Hs.eg.db")
colnames(DA_closePeaks_gene)[3] = "ENSEMBL"
# garder seulement les gènes dont on a trouvé la correspondance du nom dans la BDD
DA_closePeaks_gene = inner_join(DA_closePeaks_gene, name_correspondace, by = "ENSEMBL")

# ont = ALL => cellular components, cellular pathway...
ego <- enrichGO(gene = DA_closePeaks_gene$ENTREZID,
       OrgDb         = org.Hs.eg.db,
       ont           = "ALL",
       pAdjustMethod = "BH",
       pvalueCutoff  = 0.05,
       qvalueCutoff  = 0.2,
       readable      = TRUE)

dotplot(ego, showCategory = 20)


# refaire la même chose (ego) avec les foldchange positifs => pour avoir l'info de l'autre cluster
```









