---
title: "Complete Seurat procedure"
author: "Romuald"
date: "27/01/2022"
output: html_document
---

```{r Libraries, message=F, echo=FALSE, warning=FALSE, results='hide'}

library(Signac)
library(Seurat)
library(GenomeInfoDb)
library(EnsDb.Hsapiens.v86)# v.86= hg38 | v.75=hg19
library(ggplot2)
library(patchwork)
library(readr)
library(dplyr)
library(cowplot)
library(clusterProfiler)

```


```{r Create the Object, message=FALSE, warning=F}
counts <- Seurat::Read10X_h5(filename = "~/Bureau/scATAC_raw_data/ATAC_Ctrl_MP/filtered_peak_bc_matrix.h5")

metadata <- read.csv(
  file = "~/Bureau/scATAC_raw_data/ATAC_Ctrl_MP/singlecell.csv",
  header = TRUE,
  row.names = 1
)

chrom_assay <- CreateChromatinAssay(
  counts = counts,
  sep = c(":", "-"),
  genome = 'hg38',
  fragments = '~/Bureau/scATAC_raw_data/ATAC_Ctrl_MP/fragments.tsv.gz',
  min.cells = 100,
  min.features = 200
)

MP <- CreateSeuratObject(
  counts = chrom_assay,
  assay = "peaks",
  meta.data = metadata)

# Check for the assays informations
MP[['peaks']]

```

```{r Basic functions for information access,}
# 
# ###############
# ## METADATA ##
# #############
# 
# Cells(MP) # Cell name
# rownames(x = MP) # Peak name
# ncol(x = MP) # nb of cell
# nrow(x = MP) # nb of peaks
# 
# # Set identity classes
Idents(object = MP) <- "MP"
# 
# # Downsample the number of cells per identity class
# subset(x = MP, downsample = 100)
# 
# ##########################################
# ## cell embedding and feature loadings ##
# ########################################
# 
# # Return all reductions computed for each assay
# MP@reductions
# 
# # Info about one specific reduction
# MP@reductions$lsi
# MP[["lsi"]]
# 
# ## Access to data generated by the  dimension reduction
# 
# # Cell embeddings
# head(Embeddings(MP, reduction = "lsi"))[,1:3]
# 
# # Feature loadings
# head(Loadings(object = MP, reduction = "lsi"))[,1:3]
# 
# ########################
# ## expression matrix ##
# ######################
# 
# # Retrieve or set data in an expression matrix ('counts', 'data', and 'scale.data')
# GetAssayData(object = MP, slot = "counts") # Access the count matrix (peaks/cell)

```


```{r Create the Object, message=FALSE, warning=F}
# extract gene annotations from EnsDb and attach it to the object
# This will allow downstream function to extract gene information directly from the object instead of remote request to a server
annotations <- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v86)

# change to UCSC style since the data was mapped to hg19
seqlevelsStyle(annotations) <- 'UCSC'

# add the gene information to the object
Annotation(MP) <- annotations

```



```{r TSS Enrichment}

# compute TSS enrichment score per cell and add it to meta.data in TSS.enrichment column
MP <- TSSEnrichment(object = MP, fast = FALSE)

# Compute a new column in meta.data, based on TSS.enrichement column
MP$high.tss <- ifelse(MP$TSS.enrichment > 2, 'High', 'Low')

# Plot based on TSS.enrichment, and group according high.tss column
TSSPlot(MP, group.by = 'high.tss') + NoLegend()

```

```{r Nucleosome Signal}

# compute nucleosome signal score per cell and add it to meta.data in nucleosome_signal column
MP <- NucleosomeSignal(object = MP)

# Compute a new column in meta.data, based on nucleosome_signal column
MP$nucleosome_group <- ifelse(MP$nucleosome_signal > 4, 'NS > 4', 'NS < 4')

# Plot based on nucleosome_signal, and group according nucleosome_group column
FragmentHistogram(object = MP, group.by = 'nucleosome_group')

```

```{r QC plots}

# compute percentage of reads in peaks for each cells
MP$pct_reads_in_peaks <- MP$peak_region_fragments / MP$passed_filters * 100

# Violin plots for QC
VlnPlot(
  object = MP,
  features = c('pct_reads_in_peaks', 'peak_region_fragments', 'TSS.enrichment', 'nucleosome_signal'),
  pt.size = 0.1,
  ncol = 5
)

```

```{r Normalization, message=F, warning=F}

# Normalization: term frequency-inverse document frequency (TF-IDF) normalization. 
# Two-step normalization procedure, that both normalizes across cells to correct for differences in cellular sequencing depth, and across peaks to give higher values to more rare peaks.
MP <- RunTFIDF(MP)

# Choose to use only the top n% of features (peaks) for dimensional reduction
# Can also remove features present in less than n cells
# Set qXX to only select the top 90% features (peaks)
# Features used for dimensional reduction are automatically set as VariableFeatures() by this function.
MP <- FindTopFeatures(MP, min.cutoff = 'q10') # Drop the 10 lowest %


# Dimension reduction: singular value decomposition (SVD) on the TD-IDF matrix
# It automatically uses the features (peaks) selected above. 
# This returns a reduced dimension representation of the object 
# You can think of this as analogous to the output of PCA).
MP <- RunSVD(MP)

## ATTENTION ##
# The combined steps of TF-IDF followed by SVD are known as latent semantic indexing (LSI)

# The 1st LSI component often captures sequencing depth (technical variation) rather than biological variation
# If this is the case (< 0.7), then discard it for further analysis
DepthCor(MP)

```

```{r Umap with diff resolution}

# Compute another reduction, commonly used for RNAseq : UMAP
  ## Of note, usually UMAP is based on PCA dimension reduction, but here it's on lsi
  ## Dump the first dimension according to the graph above
MP <- RunUMAP(object = MP, reduction = 'lsi', dims = 2:10)
# => Now another reduction has been added to MP@reduction : "umap"

# Constructing the K-nearest neighbor (KNN) graph (by default)
# Edges drawn between cells with similar gene expression patterns. 
# Then, it attempts to partition this graph into highly interconnected ‘quasi-cliques’ or ‘communities’.
MP <- FindNeighbors(object = MP, reduction = 'lsi', dims = 2:10)
# => This functino adds a "graph" named peaks_snn in MP@graphs


# Based on the current default assay
## Resolution = 0.8
## Algorithm = 1 = Louvain
MP <- FindClusters(object = MP, algorithm = 3)
# => This function adds 2 new colmuns to meta.data : seurat_clusters AND peaks_snn_res.0.8. There are equivalent
# => If the name of algorithm is changed, then this 2 colmuns are replaced and a little bit different from previously

# The resolution argument that sets the “granularity” of the downstream clustering
# LEts try other
for (res in c(0.05, 0.1, 0.5, 1)) {
  
    MP <- FindClusters(
      object = MP, 
      graph.name = "peaks_snn", 
      resolution = res, 
      algorithm = 3)
}

# => Recalculate the clusters for different resoluation and store the results in new columns in meta.data
# names(MP[[]]) to see the columns added
plot_grid(
  ncol = 4, 
  DimPlot(MP, reduction = "umap", group.by = "peaks_snn_res.0.05") + ggtitle("Resolution_0.05"), 
  DimPlot(MP, reduction = "umap", group.by = "peaks_snn_res.0.1") + ggtitle("Resolution_0.1"), 
  DimPlot(MP, reduction = "umap", group.by = "peaks_snn_res.0.5") + ggtitle("Resolution_0.5"), 
  DimPlot(MP, reduction = "umap", group.by = "peaks_snn_res.1") + ggtitle("Resolution_1"))


```

```{r}

# Same approach but compare with k means method

for (k in c(2, 3, 4, 5, 10)) {
     MP@meta.data[, paste0("kmeans_", k)] <- kmeans(x = MP@reductions[["lsi"]]@cell.embeddings, centers = k, nstart = 100)$cluster
 }
 
 plot_grid(
   ncol = 3,
    DimPlot(MP, reduction = "umap", group.by = "kmeans_2") + ggtitle("kmeans_2"), 
    DimPlot(MP, reduction = "umap", group.by = "kmeans_3") + ggtitle("kmeans_3"),
    DimPlot(MP, reduction = "umap", group.by = "kmeans_4") + ggtitle("kmeans_4"),
    DimPlot(MP, reduction = "umap", group.by = "kmeans_5") + ggtitle("kmeans_5"), 
    DimPlot(MP, reduction = "umap", group.by = "kmeans_10") + ggtitle("kmeans_10"))

```


```{r Gene activity matrix}

# Create a geneactivity matrix based on the number of reads mapping to each in gene (gene body +2kb upstream)
gene.activities <- GeneActivity(MP)

# add the gene activity matrix to the Seurat object as a new assay  
MP[['RNA']] <- CreateAssayObject(counts = gene.activities)


# The count normalize it
MP <- NormalizeData(
  object = MP,
  assay = 'RNA',
  normalization.method = 'LogNormalize',
  scale.factor = median(MP$nCount_RNA)
)
# => Adds normalized data to MP[['RNA]]@data slot

```

```{r Gene activity plot}

DefaultAssay(MP) <- 'RNA'

MP <- FindVariableFeatures(object = MP, assay = 'RNA', nfeatures = 100)
# Adds a slot@var.features

FeaturePlot(
   object = MP,
   features = MP[['RNA']]@var.features[1:10],
   pt.size = 0.1,
   max.cutoff = 'q95',
   ncol = 3
 )

# Dig if valuable to dig in this direction, using gene activity matrix ... Rudi ?

```


```{r Find Differential Accessibility}

# change back to working with peaks instead of gene activities
DefaultAssay(MP) <- 'peaks'

# clust_0 = names(MP$peaks_snn_res.0.05[which(MP$peaks_snn_res.0.05 == 0)])
# clust_1 = names(MP$peaks_snn_res.0.05[which(MP$peaks_snn_res.0.05 == 1)])

new_ident = MP$peaks_snn_res.0.05
Idents(MP) <- new_ident

da_peaks <- FindMarkers(
  object = MP,
  ident.1 = 0,
  ident.2 = 1,
  min.pct = 0.05,
  test.use = 'LR',
  latent.vars = 'peak_region_fragments'
)


```



```{r Identifying peaks with high fold change}

DA_2 <- rownames(da_peaks[da_peaks$avg_log2FC < -0.5, ])

DA_2_closest <- ClosestFeature(MP, regions = DA_2)

head(DA_2_closest)

```

```{r}

name_correspondace = bitr(DA_2_closest$gene_id, fromType = "ENSEMBL", toType = "ENTREZID", OrgDb = "org.Hs.eg.db")
colnames(DA_2_closest)[3] = "ENSEMBL"

DA_2_closest = inner_join(DA_2_closest, name_correspondace, by = "ENSEMBL")

ego <- enrichGO(gene = DA_2_closest$ENTREZID,
       OrgDb         = org.Hs.eg.db,
       ont           = "ALL",
       pAdjustMethod = "BH",
       pvalueCutoff  = 0.05,
       qvalueCutoff  = 0.2,
       readable      = TRUE)

dotplot(ego, showCategory = 20)

```

