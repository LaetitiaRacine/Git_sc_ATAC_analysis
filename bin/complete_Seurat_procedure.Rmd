---
title: "scATACseq - Complete Seurat procedure"
subtitle: "Dernière modification : `r format(Sys.time(), '%d %B, %Y')`"
author: "Romuald - Laëtitia"
date: "27/01/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

*Résumé du code* : ce script permet d'analyser les données du point scATACseq sur des cellules cultivées pendant 24h en MP.  
La première partie correspond à une prise en main de la manipulation des objets Seurat.  
La deuxième partie permet de vérifier la qualité des données récupérées.  
**Code inspiré de** : https://satijalab.org/signac/articles/pbmc_vignette.html 

```{r Libraries, message=F, echo=FALSE, warning=FALSE, results='hide'}

library(Signac) # addon to Seurat library to work with scATACseq data
library(Seurat)
library(GenomeInfoDb) # Database with genome information
library(EnsDb.Hsapiens.v86) # v.86= hg38 | v.75=hg19
library(ggplot2)
library(patchwork)
library(readr)
library(dplyr)
library(cowplot)
library(clusterProfiler) # to perform gene ontology analysis
library(tidyverse) # to use mutate_all
library(kableExtra)

```

```{r Working directories}

dir_input = "~/Bureau/scATAC_raw_data/ATAC_Ctrl_MP/"
dir_output = "~/Bureau/sc_ATAC_analysis/Git_sc_ATAC_analysis/exp/complete_Seurat_procedure/"
# currentDate <- paste0(substr(Sys.Date(), 1,4), substr(Sys.Date(),6,7), substr(Sys.Date(),9, 10))
currentDate = "20220224"
dir.create(path = paste0(dir_output, "complete_Seurat_procedure/", currentDate))

```

<!--*************************************************************************-->
<br><br><br>
<!--*************************************************************************-->

# .Mise en forme des données en Objet Seurat 

```{r, Create the Object, message=F, warning=F}

counts <- Seurat::Read10X_h5(filename = paste0(dir_input, "filtered_peak_bc_matrix.h5"))

# Sequencing information
metadata <- read.csv(
  file = paste0(dir_input, "singlecell.csv"),
  header = TRUE,
  row.names = 1
)

chrom_assay <- CreateChromatinAssay(
  counts = counts,
  sep = c(":", "-"),
  genome = 'hg38',
  fragments = paste0(dir_input, "fragments.tsv.gz"), # tous les reads/cell, où ils tombent et combien de fois ils ont été trouvés (même non assignés)
  min.cells = 100,
  min.features = 200
)

seurat_obj <- CreateSeuratObject(
  counts = chrom_assay,
  assay = "peaks",
  meta.data = metadata)

# Check for the assays informations
seurat_obj[['peaks']]

# Remove unused objects
rm(chrom_assay, counts)
```

```{r, Basic functions for information access}

###############
## METADATA ##
###############

# Cells(x = seurat_obj) # Cell name
# rownames(x = seurat_obj) # Peak name
# ncol(x = seurat_obj) # nb of cell
# nrow(x = seurat_obj) # nb of peaks

# Set identity classes
Idents(object = seurat_obj) <- "MP"

# Downsample the number of cells per identity class
# Creation of a downsampled object to test and develop the code
# seurat_obj_dwn = subset(x = seurat_obj, downsample = 100)

##########################################
## cell embedding and feature loadings ##
########################################

# Return all reductions computed for each assay
# seurat_obj@reductions

# Info about one specific reduction (here we test lsi reduction)
# seurat_obj@reductions$lsi
# seurat_obj[["lsi"]]

## Access to data generated by the  dimension reduction

# Cell embeddings
# head(Embeddings(seurat_obj, reduction = "lsi"))[,1:3]

# Feature loadings
# head(Loadings(object = seurat_obj, reduction = "lsi"))[,1:3]

########################
## expression matrix ##
#######################

# Retrieve or set data in an expression matrix ('counts', 'data', and 'scale.data')
# GetAssayData(object = seurat_obj, slot = "counts") # Access the count matrix (peaks/cell)

```

```{r, Choose seurat object version}
# Do we work on all seurat_object or downsampled one ?
# seurat_obj = seurat_obj_dwn
# rm(seurat_obj_dwn)
```

```{r Add genome annotation, message=FALSE, warning=F}

# Extract gene annotations from EnsDb and attach it to the seurat object
# This will allow downstream function to extract gene information directly from the object instead of remote request to a server
annotations <- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v86)

# change to UCSC style 
seqlevelsStyle(annotations) <- 'UCSC'

# add the gene information to the seurat object
Annotation(seurat_obj) <- annotations

# Remove unused objects
rm(annotations)
```

<!--*************************************************************************-->
<br><br><br>
<!--*************************************************************************-->

# .Contrôle qualité des données de l'échantillon

```{r, TSS Enrichment}

# compute TSS enrichment score per cell and add it to meta.data in TSS.enrichment column
seurat_obj <- TSSEnrichment(object = seurat_obj, fast = FALSE)

# Compute a new column in meta.data, based on TSS.enrichment column
seurat_obj$high.tss <- ifelse(seurat_obj$TSS.enrichment > 2, 'High', 'Low')

# Plot based on TSS.enrichment, and group according high.tss column
plot_quality_tss = TSSPlot(seurat_obj, group.by = 'high.tss') + NoLegend()
plot_quality_tss

# Save 
ggsave(plot = plot_quality_tss, filename = paste0(dir_output, currentDate, "/plot_quality_tss.png"))
rm(plot_quality_tss)
```

=> Commenter le résultat ! 

```{r, Nucleosome Signal}

# Compute nucleosome signal score per cell and add it to meta.data in nucleosome_signal column
seurat_obj <- NucleosomeSignal(object = seurat_obj)

# Compute a new column in meta.data, based on nucleosome_signal column
seurat_obj$nucleosome_group <- ifelse(seurat_obj$nucleosome_signal > 4, 'NS > 4', 'NS < 4')

# Plot based on nucleosome_signal, and group according nucleosome_group column
plot_quality_nucl = FragmentHistogram(object = seurat_obj, group.by = 'nucleosome_group')
plot_quality_nucl

# Save 
ggsave(plot = plot_quality_nucl, filename = paste0(dir_output, currentDate, "/plot_quality_nucl.png"), width = 12)
rm(plot_quality_nucl)

```

=> Commenter le résultat ! 

```{r, QC plots, results = 'hold', fig.width=16, fig.height=6}

# compute percentage of reads in peaks for each cells
seurat_obj$pct_reads_in_peaks <- seurat_obj$peak_region_fragments / seurat_obj$passed_filters * 100
# peak_region_fragments of a cell = number of reads assigned to the peak studied 

# Violin plots for QC
plot_quality_vln = VlnPlot(
  object = seurat_obj,
  features = c('pct_reads_in_peaks', 'peak_region_fragments', 'TSS.enrichment', 'nucleosome_signal'),
  pt.size = 0.1,
  ncol = 5
)
plot_quality_vln

# Save 
ggsave(plot = plot_quality_vln, filename = paste0(dir_output, currentDate, "/plot_quality_vln.png"), width = 16, height = 6)
rm(plot_quality_vln)

```

=> Commenter le résultat ! 

```{r, Save FACULTATIF}
# saveRDS(object = seurat_obj, file = paste0(dir_output, currentDate, "/seurat_obj_dwn_qc.rds")) 
saveRDS(object = seurat_obj, file = paste0(dir_output, currentDate, "/seurat_obj_qc.rds")) 
```

<!--*************************************************************************-->
<br><br><br>
<!--*************************************************************************-->

# .Préproccessing des données : normalisation et réductions de dimensions

```{r, LOAD FACULTATIF}
# seurat_obj = readRDS(file = paste0(dir_output, currentDate, "/seurat_obj_dwn_qc.rds")) 
seurat_obj = readRDS(file = paste0(dir_output, currentDate, "/seurat_obj_qc.rds")) 
```

```{r, Normalization, message=F, warning=F, results = 'hold', fig.width=16, fig.height=6}

# Normalization: term frequency-inverse document frequency (TF-IDF) normalization. 
# Two-step normalization procedure, that both normalizes across cells to correct for differences in cellular sequencing depth, and across peaks to give higher values to more rare peaks.
seurat_obj <- RunTFIDF(seurat_obj)

# Choose to use only the top n% of features (peaks) for dimensional reduction
# Can also remove features present in less than n cells
# Set qXX to only select the top 90% features (peaks)
# Features used for dimensional reduction are automatically set as VariableFeatures() by this function.
seurat_obj <- FindTopFeatures(seurat_obj, min.cutoff = 'q10') # Drop the 10 lowest %

# Dimension reduction: singular value decomposition (SVD) on the TD-IDF matrix
# It automatically uses the features (peaks) selected above. 
# This returns a reduced dimension representation of the object 
# (You can think of this as analogous to the output of PCA).
seurat_obj <- RunSVD(seurat_obj)

## ATTENTION : The combined steps of TF-IDF followed by SVD are known as latent semantic indexing (LSI)
# The 1st LSI component often captures sequencing depth (technical variation) rather than biological variation
# If this is the case (< - 0.7 or > 0.7), then discard it for further analysis
plot_dim_depth = DepthCor(object = seurat_obj, assay ="peaks", reduction = "lsi", n = NULL) + 
  geom_hline(yintercept = -0.7, linetype = "dashed", color = "red") +
  geom_hline(yintercept = + 0.7, linetype = "dashed", color = "red")
plot_dim_depth # we remove lsi1

# We play on ylim to manually remove dim1 and visualize the elbow
plot_dim_elb = ElbowPlot(object = seurat_obj, ndims = 50, reduction = "lsi") + 
    ylim(0.2, 3) +
    theme(plot.background = element_rect(fill = "white"))
plot_dim_elb
# on peut aller jusqu'à 30 dimensions quand on travaille sur tout le jeu de données

# Choice of working dimensions
# fichier downsampled : Coude observé entre 5 et 10 dimensions. pour la suite, on travaille avec 10 dimensions. 
# All data set : coude observé entre 20 et 30 dimensions, on choisit d'utiliser 30 dimensions.
# Quand doute sur le nombre de dims à conserver : il vaut mieux en prendre plus que pas assez
dims_choice = c(2:30)
dims_choice_char = "2-30"

# Save
ggsave(plot = plot_dim_depth | plot_dim_elb, filename = paste0(dir_output, currentDate, "/plot_preprocess_dim.png"), width = 18, height = 6)
rm(plot_dim_elb, plot_dim_depth)
```

```{r, Umap with diff resolution, results = 'hold', fig.width=16, fig.height=10}

# Compute another reduction (commonly used for RNAseq) : UMAP
  ## Of note, usually UMAP is based on PCA dimension reduction, but here it's on lsi
  ## Dump the first dimension according to the graph above
seurat_obj <- RunUMAP(object = seurat_obj, reduction = 'lsi', dims = dims_choice)
# => Now another reduction has been added to seurat_obj@reduction : "umap"

# Constructing the K-nearest neighbor (KNN) graph (by default)
# Edges drawn between cells with similar gene expression patterns. 
# Then, it attempts to partition this graph into highly interconnected ‘quasi-cliques’ or ‘communities’.
seurat_obj <- FindNeighbors(object = seurat_obj, reduction = 'lsi', dims = dims_choice)
# => This function adds a "graph" named peaks_snn in seurat_obj@graphs

# Based on the current default assay
## Resolution = 0.8
## Algorithm = 1 = Louvain
seurat_obj <- FindClusters(object = seurat_obj, algorithm = 3)
# => This function adds 2 new columns to meta.data : seurat_clusters AND peaks_snn_res.0.8. There are equivalent
# => If the name of algorithm is changed, then this 2 columns are replaced and a little bit different from previously

# Try different resolution argument that sets the “granularity” of the downstream clustering
for (res in c(0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 0.8, 1)) {
    seurat_obj <- FindClusters(
      object = seurat_obj, 
      graph.name = "peaks_snn", 
      resolution = res, 
      algorithm = 3)
}

# => Recalculate the clusters for different resolution and store the results in new columns in meta.data
# names(seurat_obj[[]]) # to see the columns added
plot_resolution = plot_grid(
  ncol = 3, 
  nrow = 3,
  DimPlot(seurat_obj, reduction = "umap", group.by = "peaks_snn_res.0.01") + ggtitle("Resolution_0.01"),
  DimPlot(seurat_obj, reduction = "umap", group.by = "peaks_snn_res.0.02") + ggtitle("Resolution_0.02"),
  DimPlot(seurat_obj, reduction = "umap", group.by = "peaks_snn_res.0.05") + ggtitle("Resolution_0.05"),
  DimPlot(seurat_obj, reduction = "umap", group.by = "peaks_snn_res.0.1") + ggtitle("Resolution_0.1"),
  DimPlot(seurat_obj, reduction = "umap", group.by = "peaks_snn_res.0.2") + ggtitle("Resolution_0.2"),
  DimPlot(seurat_obj, reduction = "umap", group.by = "peaks_snn_res.0.5") + ggtitle("Resolution_0.5"),
  DimPlot(seurat_obj, reduction = "umap", group.by = "peaks_snn_res.0.8") + ggtitle("Resolution_0.8"),
  DimPlot(seurat_obj, reduction = "umap", group.by = "peaks_snn_res.1") + ggtitle("Resolution_1"))
plot_resolution

# Save 
ggsave(plot = plot_resolution, 
       filename = paste0(dir_output, currentDate, "/plot_dim", dims_choice_char, "_resolution.png"), 
       width = 18, height = 10)
rm(plot_resolution, res)
```

=> pk algo = 3 ???
Commentaire : résolution au dessus de 0.05 ne sépare pas bien les clusters. On choisit des valeurs en dessous. => se renseigner pour voir si c'est mieux de prendre la plus élevée possible ou pas 

```{r, Umap with diff kmean, results = 'hold', fig.width=16, fig.height=8}

# Same approach but compare with k means method

for (k in c(2, 3, 4, 5, 10)) {
     seurat_obj@meta.data[, paste0("kmeans_", k)] <- kmeans(x = seurat_obj@reductions[["lsi"]]@cell.embeddings, centers = k, nstart = 100)$cluster
 }
 
plot_kmean = plot_grid(
   ncol = 3,
    DimPlot(seurat_obj, reduction = "umap", group.by = "kmeans_2") + ggtitle("kmeans_2"), 
    DimPlot(seurat_obj, reduction = "umap", group.by = "kmeans_3") + ggtitle("kmeans_3"),
    DimPlot(seurat_obj, reduction = "umap", group.by = "kmeans_4") + ggtitle("kmeans_4"),
    DimPlot(seurat_obj, reduction = "umap", group.by = "kmeans_5") + ggtitle("kmeans_5"), 
    DimPlot(seurat_obj, reduction = "umap", group.by = "kmeans_10") + ggtitle("kmeans_10"))
plot_kmean

# Save plot
ggsave(plot = plot_kmean, 
       filename = paste0(dir_output, currentDate, "/plot_dim", dims_choice_char, "_kmean.png"), 
       width = 18, height = 8)
rm(plot_kmean, k)

```

```{r, Save FACULTATIF}
# saveRDS(object = seurat_obj, file = paste0(dir_output, currentDate, "/seurat_obj_dwn_preprocess_dim", dims_choice_char,".rds")) 
saveRDS(object = seurat_obj, file = paste0(dir_output, currentDate, "/seurat_obj_preprocess_dim", dims_choice_char,".rds")) 
```


<!--*************************************************************************-->
<br><br><br>
<!--*************************************************************************-->



# .Association des peaks à l'activité du gène le plus proche

```{r, Load FACULTATIF}
# seurat_obj = readRDS(file = paste0(dir_output, currentDate, "/seurat_obj_dwn_preprocess_dim2-10.rds")) 
seurat_obj = readRDS(file = paste0(dir_output, currentDate, "/seurat_obj_preprocess_dim2-30.rds")) 
```

```{r Gene activity matrix}

# Transfo les données ATAC en équivalent RNA : convertit le nombre de reads comme si c'était des UMI

# Create a gene activity matrix based on the number of reads mapping to each in gene (gene body +2kb upstream)
gene.activities <- GeneActivity(seurat_obj)

# add the gene activity matrix to the Seurat object as a new assay  
seurat_obj[['RNA']] <- CreateAssayObject(counts = gene.activities)
rm(gene.activities)

# The count normalizes it
seurat_obj <- NormalizeData(
  object = seurat_obj,
  assay = 'RNA',
  normalization.method = 'LogNormalize',
  scale.factor = median(seurat_obj$nCount_RNA)
)
# => Adds normalized data to seurat_obj[['RNA]]@data slot

```

```{r Gene activity plot, results = 'hold', fig.width=16, fig.height=12}

DefaultAssay(seurat_obj) <- 'RNA'

seurat_obj <- FindVariableFeatures(object = seurat_obj, assay = 'RNA', nfeatures = 100)
# Adds a slot@var.features

# On garde la reduction PCA de ATACseq donc les mêmes clusters
# On "colle" par dessus l'info des gènes exprimés
# Possibilité de regarder un gène particulier !
plot_varfeature = FeaturePlot(
  object = seurat_obj,
  features = seurat_obj[['RNA']]@var.features[1:10],
  pt.size = 0.1,
  max.cutoff = 'q95',
  ncol = 3
)
plot_varfeature

# Save
ggsave(plot = plot_varfeature, 
       filename = paste0(dir_output, currentDate, "/plot_dim", dims_choice_char, "_varfeature.png"), 
       width = 18, height = 16)
rm(plot_varfeature)
```
Dig if valuable to dig in this direction, using gene activity matrix ... Rudi ?

```{r, Save FACULTATIF}
# saveRDS(object = seurat_obj, file = paste0(dir_output, currentDate, "/seurat_obj_dwn_geneact_dim", dims_choice_char, ".rds")) 
saveRDS(object = seurat_obj, file = paste0(dir_output, currentDate, "/seurat_obj_geneact_dim", dims_choice_char, ".rds")) 
```


<!--*************************************************************************-->}
<br><br><br>
<!--*************************************************************************-->



# .Investigation sur les clusters obtenus 

```{r, Load FACULTATIF}
# seurat_obj = readRDS(file = paste0(dir_output, currentDate, "/seurat_obj_dwn_geneact_dim2-10.rds")) 
seurat_obj = readRDS(file = paste0(dir_output, currentDate, "/seurat_obj_geneact_dim2-30.rds")) 
```

```{r, Change DefaultAssay}
# Change back to working with peaks instead of gene activities
DefaultAssay(seurat_obj) <- 'peaks'
```

```{r, Peaks distribution accross clusters}

# Choose your resolutions
res = "res0.1"
# à écrire si inspiré

tab_peak_clust = data.frame(cell = character(), nbpeaks = numeric(), clust = character())

# Changer la résolution à la main !!!
for (i in 1:length(levels(seurat_obj$peaks_snn_res.0.1))) {
  
  # Extract cluster number
  clust = levels(seurat_obj$peaks_snn_res.0.1)[i]
  # Create subset of seurat object with cells from clust x
  seurat_clust = subset(seurat_obj, subset = peaks_snn_res.0.1 == clust)
  # Check if the subset was correctly done
  print(table(seurat_clust@meta.data$peaks_snn_res.0.1)) 
  # Extract peak count matrix of clust x from general seurat object
  tab_clust = as.data.frame(GetAssayData(seurat_clust, slot = "data")) 
  # Transform count into logical
  tab_clust = tab_clust %>% mutate_all(as.logical)
  # Calculate number of peaks detected per cell
  tab_clust = data.frame(nbpeaks = colSums(tab_clust)) %>% 
    tibble::rownames_to_column(var = "cell") %>%
    dplyr::mutate(clust = clust)
  # Bind in general tab
  tab_peak_clust = rbind(tab_clust, tab_peak_clust)
  
}

tab_peak_stat = tab_peak_clust %>%
  dplyr::group_by(clust) %>%
  dplyr::mutate(nbcells = n(),
                median_nbpeaks = median(nbpeaks),
                mean_nbpeaks = round(mean(nbpeaks)),
                max_nbpeaks = max(nbpeaks),
                min_nbpeaks = min(nbpeaks),
                var_nbpeaks = round(sd(nbpeaks))) %>%
  dplyr::ungroup() %>%
  dplyr::select(clust, nbcells, median_nbpeaks, mean_nbpeaks, max_nbpeaks, min_nbpeaks, var_nbpeaks) %>%
  dplyr::distinct()
tab_peak_stat %>% kable(caption = res) %>% kable_styling()

plot_peak_clust = ggplot(tab_peak_clust, aes(x = nbpeaks, fill = clust)) +
  geom_histogram(bins = 50, color = "black", alpha = 0.5) +
  ggtitle(label = paste0("Distribution of peaks' number per cell according to cluster - ", res))
plot_peak_clust

# Save objects and clean working space
ggsave(plot = plot_peak_clust, 
       filename = paste0(dir_output, currentDate, "/plot_dim", dims_choice_char, "_", res, "_peaks_clust.png"), 
       width = 8, height = 6)
write_csv2(tab_peak_clust, file = paste0(dir_output, currentDate, "/tab_dim", dims_choice_char, "_",res, "_peaks_clust.csv"))
write_csv2(tab_peak_stat, file = paste0(dir_output, currentDate, "/tab_dim", dims_choice_char, "_", res, "_peaks_stat.csv"))
rm(i, clust, seurat_clust, tab_clust, plot_peak_clust, tab_peak_clust, tab_peak_stat)

```

```{r, Peaks distribution accross clusters in annotations}
# faire la même chose seulement sur les peaks qui tombent sur les TSS (il y a une fonction normalement qui existe pour ça (avec grange ou autre))
# pour chacun des deux clusters, faire la même distribution mais pour chaque élément/annotation génomique et faire les histogrammes comme pour le bulk
```

```{r, Find Differential Accessibility}

# Extract cells from clust0 and clust1
# clust0_cells = names(seurat_obj$peaks_snn_res.0.05[which(seurat_obj$peaks_snn_res.0.05 == 0)])
# nbcells_clust0 = length(clust0_cells)
# clust1_cells = names(seurat_obj$peaks_snn_res.0.05[which(seurat_obj$peaks_snn_res.0.05 == 1)])
# nbcells_clust1 = length(clust1_cells)


# Take values from 0.05 resolution
Idents(seurat_obj) = seurat_obj$peaks_snn_res.0.05

# Compare clsuters
da_peaks <- FindMarkers(
  object = seurat_obj,
  ident.1 = 0,
  ident.2 = 1,
  min.pct = 0.05,  # au mini le peak doit être partagé par 5% de la pop
  test.use = 'LR',
  latent.vars = 'peak_region_fragments',
  verbose = TRUE
)
# ident.1 : identity class to define markers for 
# ident.2 : a second identity class for comparison
# avg_logFC: Positive values indicate that the gene is more highly expressed in the first group
# si foldchange > 0.5, alors cells de ident1 plus accessibles que celles de ident2
# si foldchange < -0.5, alors cells de ident1 moins accessibles que celles de ident2
# pct.1: The percentage of cells where the gene is detected in the first group
# pct.2: The percentage of cells where the gene is detected in the second group
head(da_peaks)

# Récuparation du nom des peaks qui ont log2FC sup à 0.5
# pb : que des fold-change négatif : que des peaks qui se ferment dans le petit groupes ??? erreur ou pas DA_1 = empty
# vérifier les paramètres FindMarkers
DA_openPeaks <- rownames(da_peaks[da_peaks$avg_log2FC > 0.5, ])
# Récuparation du nom des peaks qui ont log2FC inf à -0.5
DA_closePeaks <- rownames(da_peaks[da_peaks$avg_log2FC < -0.5, ])

```

```{r Identifying peaks with high fold change}

# Récupère le gène le plus proche des peaks identifiés
# on obtient un tableau => vérifier si on a l'info de la fiabilité de l'attribution des gènes dans les peaks
DA_closePeaks_gene <- ClosestFeature(seurat_obj, regions = DA_closePeaks)
head(DA_closePeaks_gene)
# DA_openPeaks_gene <- ClosestFeature(seurat_obj, regions = DA_openPeaks)
# head(DA_openPeaks_gene)

```

```{r Gene Ontology}

# Sur les peaks qui sont plus fermés : 

# Code issu de l'analyse MARS ATAC = ne pas modifier
name_correspondace = bitr(DA_closePeaks_gene$gene_id, fromType = "ENSEMBL", toType = "ENTREZID", OrgDb = "org.Hs.eg.db")
colnames(DA_closePeaks_gene)[3] = "ENSEMBL"
# garder seulement les gènes dont on a trouvé la correspondance du nom dans la BDD
DA_closePeaks_gene = inner_join(DA_closePeaks_gene, name_correspondace, by = "ENSEMBL")

# ont = ALL => cellular components, cellular pathway...
ego <- enrichGO(gene = DA_closePeaks_gene$ENTREZID,
       OrgDb         = org.Hs.eg.db,
       ont           = "ALL",
       pAdjustMethod = "BH",
       pvalueCutoff  = 0.05,
       qvalueCutoff  = 0.2,
       readable      = TRUE)

dotplot(ego, showCategory = 20)


# refaire la même chose (ego) avec les foldchange positifs => pour avoir l'info de l'autre cluster
```

```{r, Cluster gene specific }
# sortir la liste de tous les gènes qui ont un peak dans le clust0, dans le clust1, enlever l'intersection et regarder ce qui n'est pas en commun :
  # - sous sampling que les peaks qui tombent dans TSS (refaire FindMarkers ?)
  # - utiliser closest feature sur tous ces peaks par cluster
  # - faire l'exclusion pour sortir la liste particulière de chaque cluster
  # - GO sur les deux listes
```

```{r AddChromatinModule}

# Trouver des listes de gènes qui  nous intéressent, genre "souche, cellule T" ou bien même encore plus simplement les listes des gènes de chaque cluster de CALISTA (!)
# Choper les peaks qui tombe dans les TSS de ces gènes là
# Donner ces listes de gènes à la fonction AddChromatinModule
# Espèrer que le gros cluster corresponde au cluster 2 de Calista et que le petit au cluster 3/4/5
# Ou alors  espèrer que le gros cluster ait une signature plus "souche" que le cluster petit
```














