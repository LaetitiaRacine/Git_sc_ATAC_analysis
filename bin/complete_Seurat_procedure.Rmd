---
title: "scATACseq - Complete Seurat procedure"
subtitle: "Dernière modification : `r format(Sys.time(), '%d %B, %Y')`"
author: "Romuald - Laëtitia"
date: "27/01/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

*Résumé du code* : ce script permet d'analyser les données du point scATACseq sur des cellules cultivées pendant 24h en MP.  
La première partie correspond à une prise en main de la manipulation des objets Seurat.  
La deuxième partie permet de vérifier la qualité des données récupérées.  
**Code inspiré de** : https://satijalab.org/signac/articles/pbmc_vignette.html 

```{r Libraries, message=F, echo=FALSE, warning=FALSE, results='hide'}

library(Signac) # addon to Seurat library to work with scATACseq data
library(Seurat)
library(GenomeInfoDb) # Database with genome information
library(EnsDb.Hsapiens.v86) # v.86= hg38 | v.75=hg19
library(ggplot2)
library(patchwork)
library(readr)
library(dplyr)
library(cowplot)
library(clusterProfiler) # to perform gene ontology analysis
library(tidyverse) # to use mutate_all
library(kableExtra)

```

```{r Working directories}

dir_git = "~/Bureau/sc_ATAC_analysis/Git_sc_ATAC_analysis/"
dir_input = "~/Bureau/scATAC_raw_data/ATAC_Ctrl_MP/"
dir_output = "~/Bureau/sc_ATAC_analysis/Git_sc_ATAC_analysis/exp/complete_Seurat_procedure/"
# currentDate <- paste0(substr(Sys.Date(), 1,4), substr(Sys.Date(),6,7), substr(Sys.Date(),9, 10))
currentDate = "20220224"
dir.create(path = paste0(dir_output, "complete_Seurat_procedure/", currentDate))

# à effacer quand code fini (redondant avec partie préprocessing)
dims_choice = "2:30"
```

<!--*************************************************************************-->
<br><br><br>
<!--*************************************************************************-->

# .Mise en forme des données en Objet Seurat 

```{r, Create the Object, message=F, warning=F}

counts <- Seurat::Read10X_h5(filename = paste0(dir_input, "filtered_peak_bc_matrix.h5"))

# Sequencing information
metadata <- read.csv(
  file = paste0(dir_input, "singlecell.csv"),
  header = TRUE,
  row.names = 1
)

chrom_assay <- CreateChromatinAssay(
  counts = counts,
  sep = c(":", "-"),
  genome = 'hg38',
  fragments = paste0(dir_input, "fragments.tsv.gz"), # tous les reads/cell, où ils tombent et combien de fois ils ont été trouvés (même non assignés)
  min.cells = 100,
  min.features = 200
)

seurat_obj <- CreateSeuratObject(
  counts = chrom_assay,
  assay = "peaks",
  meta.data = metadata)

# Check for the assays informations
seurat_obj[['peaks']]

# Remove unused objects
rm(chrom_assay, counts)
```

```{r, Basic functions for information access}

###############
## METADATA ##
###############

# Cells(x = seurat_obj) # Cell name
# rownames(x = seurat_obj) # Peak name
# ncol(x = seurat_obj) # nb of cell
# nrow(x = seurat_obj) # nb of peaks

# Set identity classes
Idents(object = seurat_obj) <- "MP"

# Downsample the number of cells per identity class
# Creation of a downsampled object to test and develop the code
# seurat_obj_dwn = subset(x = seurat_obj, downsample = 100)

##########################################
## cell embedding and feature loadings ##
########################################

# Return all reductions computed for each assay
# seurat_obj@reductions

# Info about one specific reduction (here we test lsi reduction)
# seurat_obj@reductions$lsi
# seurat_obj[["lsi"]]

## Access to data generated by the  dimension reduction

# Cell embeddings
# head(Embeddings(seurat_obj, reduction = "lsi"))[,1:3]

# Feature loadings
# head(Loadings(object = seurat_obj, reduction = "lsi"))[,1:3]

########################
## expression matrix ##
#######################

# Retrieve or set data in an expression matrix ('counts', 'data', and 'scale.data')
# GetAssayData(object = seurat_obj, slot = "counts") # Access the count matrix (peaks/cell)

```

```{r, Choose seurat object version}
# Do we work on all seurat_object or downsampled one ?
# seurat_obj = seurat_obj_dwn
# rm(seurat_obj_dwn)
```

```{r Add genome annotation, message=FALSE, warning=F}

# Extract gene annotations from EnsDb and attach it to the seurat object
# This will allow downstream function to extract gene information directly from the object instead of remote request to a server
annotations <- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v86)

# change to UCSC style 
seqlevelsStyle(annotations) <- 'UCSC'

# add the gene information to the seurat object
Annotation(seurat_obj) <- annotations

# Remove unused objects
rm(annotations)
```

<!--*************************************************************************-->
<br><br><br>
<!--*************************************************************************-->

# .Contrôle qualité des données de l'échantillon

```{r, TSS Enrichment}

# compute TSS enrichment score per cell and add it to meta.data in TSS.enrichment column
seurat_obj <- TSSEnrichment(object = seurat_obj, fast = FALSE)

# Compute a new column in meta.data, based on TSS.enrichment column
seurat_obj$high.tss <- ifelse(seurat_obj$TSS.enrichment > 2, 'High', 'Low')

# Plot based on TSS.enrichment, and group according high.tss column
plot_quality_tss = TSSPlot(seurat_obj, group.by = 'high.tss') + NoLegend()
plot_quality_tss

# Save 
ggsave(plot = plot_quality_tss, filename = paste0(dir_output, currentDate, "/plot_quality_tss.png"))
rm(plot_quality_tss)
```

=> Commenter le résultat ! 

```{r, Nucleosome Signal}

# Compute nucleosome signal score per cell and add it to meta.data in nucleosome_signal column
seurat_obj <- NucleosomeSignal(object = seurat_obj)

# Compute a new column in meta.data, based on nucleosome_signal column
seurat_obj$nucleosome_group <- ifelse(seurat_obj$nucleosome_signal > 4, 'NS > 4', 'NS < 4')

# Plot based on nucleosome_signal, and group according nucleosome_group column
plot_quality_nucl = FragmentHistogram(object = seurat_obj, group.by = 'nucleosome_group')
plot_quality_nucl

# Save 
ggsave(plot = plot_quality_nucl, filename = paste0(dir_output, currentDate, "/plot_quality_nucl.png"), width = 12)
rm(plot_quality_nucl)

```

=> Commenter le résultat ! 

```{r, QC plots, results = 'hold', fig.width=16, fig.height=6}

# compute percentage of reads in peaks for each cells
seurat_obj$pct_reads_in_peaks <- seurat_obj$peak_region_fragments / seurat_obj$passed_filters * 100
# peak_region_fragments of a cell = number of reads assigned to the peak studied 

# Violin plots for QC
plot_quality_vln = VlnPlot(
  object = seurat_obj,
  features = c('pct_reads_in_peaks', 'peak_region_fragments', 'TSS.enrichment', 'nucleosome_signal'),
  pt.size = 0.1,
  ncol = 5
)
plot_quality_vln

# Save 
ggsave(plot = plot_quality_vln, filename = paste0(dir_output, currentDate, "/plot_quality_vln.png"), width = 16, height = 6)
rm(plot_quality_vln)

```

=> Commenter le résultat ! 

```{r, Save FACULTATIF}
# saveRDS(object = seurat_obj, file = paste0(dir_output, currentDate, "/seurat_obj_dwn_qc.rds")) 
saveRDS(object = seurat_obj, file = paste0(dir_output, currentDate, "/seurat_obj_qc.rds")) 
```

<!--*************************************************************************-->
<br><br><br>
<!--*************************************************************************-->

# .Préproccessing des données : normalisation et réductions de dimensions

```{r, LOAD FACULTATIF}
# seurat_obj = readRDS(file = paste0(dir_output, currentDate, "/seurat_obj_dwn_qc.rds")) 
seurat_obj = readRDS(file = paste0(dir_output, currentDate, "/seurat_obj_qc.rds")) 
```

```{r, Normalization, message=F, warning=F, results = 'hold', fig.width=16, fig.height=6}

# Normalization: term frequency-inverse document frequency (TF-IDF) normalization. 
# Two-step normalization procedure, that both normalizes across cells to correct for differences in cellular sequencing depth, and across peaks to give higher values to more rare peaks.
seurat_obj <- RunTFIDF(seurat_obj)

# Choose to use only the top n% of features (peaks) for dimensional reduction
# Can also remove features present in less than n cells
# Set qXX to only select the top 90% features (peaks)
# Features used for dimensional reduction are automatically set as VariableFeatures() by this function.
seurat_obj <- FindTopFeatures(seurat_obj, min.cutoff = 'q10') # Drop the 10 lowest %

# Dimension reduction: singular value decomposition (SVD) on the TD-IDF matrix
# It automatically uses the features (peaks) selected above. 
# This returns a reduced dimension representation of the object 
# (You can think of this as analogous to the output of PCA).
seurat_obj <- RunSVD(seurat_obj)

## ATTENTION : The combined steps of TF-IDF followed by SVD are known as latent semantic indexing (LSI)
# The 1st LSI component often captures sequencing depth (technical variation) rather than biological variation
# If this is the case (< - 0.7 or > 0.7), then discard it for further analysis
plot_dim_depth = DepthCor(object = seurat_obj, assay ="peaks", reduction = "lsi", n = NULL) + 
  geom_hline(yintercept = -0.7, linetype = "dashed", color = "red") +
  geom_hline(yintercept = + 0.7, linetype = "dashed", color = "red")
plot_dim_depth # we remove lsi1

# We play on ylim to manually remove dim1 and visualize the elbow
plot_dim_elb = ElbowPlot(object = seurat_obj, ndims = 50, reduction = "lsi") + 
    ylim(0.2, 3) +
    theme(plot.background = element_rect(fill = "white"))
plot_dim_elb
# on peut aller jusqu'à 30 dimensions quand on travaille sur tout le jeu de données

# Choice of working dimensions
# fichier downsampled : Coude observé entre 5 et 10 dimensions. pour la suite, on travaille avec 10 dimensions. 
# All data set : coude observé entre 20 et 30 dimensions, on choisit d'utiliser 30 dimensions.
# Quand doute sur le nombre de dims à conserver : il vaut mieux en prendre plus que pas assez
dims_choice = c(2:30)
dims_choice_char = "2-30"

# Save
ggsave(plot = plot_dim_depth | plot_dim_elb, filename = paste0(dir_output, currentDate, "/plot_preprocess_dim.png"), width = 18, height = 6)
rm(plot_dim_elb, plot_dim_depth)
```

```{r, Umap with diff resolution, results = 'hold', fig.width=16, fig.height=10}

# Compute another reduction (commonly used for RNAseq) : UMAP
  ## Of note, usually UMAP is based on PCA dimension reduction, but here it's on lsi
  ## Dump the first dimension according to the graph above
seurat_obj <- RunUMAP(object = seurat_obj, reduction = 'lsi', dims = dims_choice)
# => Now another reduction has been added to seurat_obj@reduction : "umap"

# Constructing the K-nearest neighbor (KNN) graph (by default)
# Edges drawn between cells with similar gene expression patterns. 
# Then, it attempts to partition this graph into highly interconnected ‘quasi-cliques’ or ‘communities’.
seurat_obj <- FindNeighbors(object = seurat_obj, reduction = 'lsi', dims = dims_choice)
# => This function adds a "graph" named peaks_snn in seurat_obj@graphs

# Based on the current default assay
## Resolution = 0.8
## Algorithm = 1 = Louvain
seurat_obj <- FindClusters(object = seurat_obj, algorithm = 3)
# => This function adds 2 new columns to meta.data : seurat_clusters AND peaks_snn_res.0.8. There are equivalent
# => If the name of algorithm is changed, then this 2 columns are replaced and a little bit different from previously

# Try different resolution argument that sets the “granularity” of the downstream clustering
for (res in c(0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 0.8, 1)) {
    seurat_obj <- FindClusters(
      object = seurat_obj, 
      graph.name = "peaks_snn", 
      resolution = res, 
      algorithm = 3)
}

# => Recalculate the clusters for different resolution and store the results in new columns in meta.data
# names(seurat_obj[[]]) # to see the columns added
plot_resolution = plot_grid(
  ncol = 3, 
  nrow = 3,
  DimPlot(seurat_obj, reduction = "umap", group.by = "peaks_snn_res.0.01") + ggtitle("Resolution_0.01"),
  DimPlot(seurat_obj, reduction = "umap", group.by = "peaks_snn_res.0.02") + ggtitle("Resolution_0.02"),
  DimPlot(seurat_obj, reduction = "umap", group.by = "peaks_snn_res.0.05") + ggtitle("Resolution_0.05"),
  DimPlot(seurat_obj, reduction = "umap", group.by = "peaks_snn_res.0.1") + ggtitle("Resolution_0.1"),
  DimPlot(seurat_obj, reduction = "umap", group.by = "peaks_snn_res.0.2") + ggtitle("Resolution_0.2"),
  DimPlot(seurat_obj, reduction = "umap", group.by = "peaks_snn_res.0.5") + ggtitle("Resolution_0.5"),
  DimPlot(seurat_obj, reduction = "umap", group.by = "peaks_snn_res.0.8") + ggtitle("Resolution_0.8"),
  DimPlot(seurat_obj, reduction = "umap", group.by = "peaks_snn_res.1") + ggtitle("Resolution_1"))
plot_resolution

# Save 
ggsave(plot = plot_resolution, 
       filename = paste0(dir_output, currentDate, "/plot_dim", dims_choice_char, "_resolution.png"), 
       width = 18, height = 10)
rm(plot_resolution, res)
```

=> pk algo = 3 ???
Commentaire : résolution au dessus de 0.05 ne sépare pas bien les clusters. On choisit des valeurs en dessous. => se renseigner pour voir si c'est mieux de prendre la plus élevée possible ou pas 

```{r, Umap with diff kmean, results = 'hold', fig.width=16, fig.height=8}

# Same approach but compare with k means method

for (k in c(2, 3, 4, 5, 10)) {
     seurat_obj@meta.data[, paste0("kmeans_", k)] <- kmeans(x = seurat_obj@reductions[["lsi"]]@cell.embeddings, centers = k, nstart = 100)$cluster
 }
 
plot_kmean = plot_grid(
   ncol = 3,
    DimPlot(seurat_obj, reduction = "umap", group.by = "kmeans_2") + ggtitle("kmeans_2"), 
    DimPlot(seurat_obj, reduction = "umap", group.by = "kmeans_3") + ggtitle("kmeans_3"),
    DimPlot(seurat_obj, reduction = "umap", group.by = "kmeans_4") + ggtitle("kmeans_4"),
    DimPlot(seurat_obj, reduction = "umap", group.by = "kmeans_5") + ggtitle("kmeans_5"), 
    DimPlot(seurat_obj, reduction = "umap", group.by = "kmeans_10") + ggtitle("kmeans_10"))
plot_kmean

# Save plot
ggsave(plot = plot_kmean, 
       filename = paste0(dir_output, currentDate, "/plot_dim", dims_choice_char, "_kmean.png"), 
       width = 18, height = 8)
rm(plot_kmean, k)

```

```{r, Save FACULTATIF}
# saveRDS(object = seurat_obj, file = paste0(dir_output, currentDate, "/seurat_obj_dwn_preprocess_dim", dims_choice_char,".rds")) 
saveRDS(object = seurat_obj, file = paste0(dir_output, currentDate, "/seurat_obj_preprocess_dim", dims_choice_char,".rds")) 
```


<!--*************************************************************************-->
<br><br><br>
<!--*************************************************************************-->



# .Association des peaks à l'activité du gène le plus proche

```{r, Load FACULTATIF}
# seurat_obj = readRDS(file = paste0(dir_output, currentDate, "/seurat_obj_dwn_preprocess_dim2-10.rds")) 
seurat_obj = readRDS(file = paste0(dir_output, currentDate, "/seurat_obj_preprocess_dim2-30.rds")) 
```

```{r Gene activity matrix}

# Transfo les données ATAC en équivalent RNA : convertit le nombre de reads comme si c'était des UMI

# Create a gene activity matrix based on the number of reads mapping to each in gene (gene body +2kb upstream)
gene.activities <- GeneActivity(seurat_obj)

# add the gene activity matrix to the Seurat object as a new assay  
seurat_obj[['RNA']] <- CreateAssayObject(counts = gene.activities)
rm(gene.activities)

# The count normalizes it
seurat_obj <- NormalizeData(
  object = seurat_obj,
  assay = 'RNA',
  normalization.method = 'LogNormalize',
  scale.factor = median(seurat_obj$nCount_RNA)
)
# => Adds normalized data to seurat_obj[['RNA]]@data slot

```

```{r Gene activity plot, results = 'hold', fig.width=16, fig.height=12}

DefaultAssay(seurat_obj) <- 'RNA'

seurat_obj <- FindVariableFeatures(object = seurat_obj, assay = 'RNA', nfeatures = 100)
# Adds a slot@var.features

# On garde la reduction PCA de ATACseq donc les mêmes clusters
# On "colle" par dessus l'info des gènes exprimés
# Possibilité de regarder un gène particulier !
plot_varfeature = FeaturePlot(
  object = seurat_obj,
  features = seurat_obj[['RNA']]@var.features[1:10],
  pt.size = 0.1,
  max.cutoff = 'q95',
  ncol = 3
)
plot_varfeature

# Save
ggsave(plot = plot_varfeature, 
       filename = paste0(dir_output, currentDate, "/plot_dim", dims_choice_char, "_varfeature.png"), 
       width = 18, height = 16)
rm(plot_varfeature)
```
Dig if valuable to dig in this direction, using gene activity matrix ... Rudi ?

```{r, Save FACULTATIF}
# saveRDS(object = seurat_obj, file = paste0(dir_output, currentDate, "/seurat_obj_dwn_geneact_dim", dims_choice_char, ".rds")) 
saveRDS(object = seurat_obj, file = paste0(dir_output, currentDate, "/seurat_obj_geneact_dim", dims_choice_char, ".rds")) 
```


<!--*************************************************************************-->}
<br><br><br>
<!--*************************************************************************-->



# .Investigation sur les clusters obtenus 

```{r, Load FACULTATIF}
# seurat_obj = readRDS(file = paste0(dir_output, currentDate, "/seurat_obj_dwn_geneact_dim2-10.rds")) 
seurat_obj = readRDS(file = paste0(dir_output, currentDate, "/seurat_obj_geneact_dim2-30.rds")) 
```

```{r, Change DefaultAssay and choose resolution}

# Change back to working with peaks instead of gene activities
DefaultAssay(seurat_obj) <- 'peaks'

# Choose working resolution
res = "res.0.05"

```

FONCTIONNEL MAIS A RETRAVAILLER / COMPLETER 

```{r, Find Differential Accessibility}

# Extract cells from clust0 and clust1
# clust0_cells = names(seurat_obj$peaks_snn_res.0.05[which(seurat_obj$peaks_snn_res.0.05 == 0)])
# nbcells_clust0 = length(clust0_cells)
# clust1_cells = names(seurat_obj$peaks_snn_res.0.05[which(seurat_obj$peaks_snn_res.0.05 == 1)])
# nbcells_clust1 = length(clust1_cells)

# Take values from 0.05 resolution
Idents(seurat_obj) = seurat_obj$peaks_snn_res.0.05

# Compare clusters
da_peaks <- FindMarkers(
  object = seurat_obj,
  ident.1 = 0,
  ident.2 = 1,
  min.pct = 0.05,  # au minimum le peak doit être partagé par 5% de la pop
  test.use = 'LR',
  latent.vars = 'peak_region_fragments',
  verbose = TRUE
)
# ident.1 : identity class to define markers for 
# ident.2 : a second identity class for comparison
# avg_logFC: Positive values indicate that the gene is more highly expressed in the first group
# si foldchange > 0.5, alors cells de ident1 plus accessibles que celles de ident2
# si foldchange < -0.5, alors cells de ident1 moins accessibles que celles de ident2
# pct.1: The percentage of cells where the gene is detected in the first group
# pct.2: The percentage of cells where the gene is detected in the second group
head(da_peaks)

# Extract peaks with log2FC > 0.5
DA_openPeaks <- rownames(da_peaks[da_peaks$avg_log2FC > 0.5, ])
# Extract peaks with log2FC < - 0.5
DA_closePeaks <- rownames(da_peaks[da_peaks$avg_log2FC < -0.5, ])

# pb : que des fold-change négatif : que des peaks qui se ferment dans le petit groupes ??? erreur ou pas DA_1 = empty
# les deux sont empty quand on choisit une résolution de 0.1 et 0.2
```

```{r Identifying peaks with high fold change}

# Place peaks on genome and determine the closest gene
# on obtient un tableau => vérifier si on a l'info de la fiabilité de l'attribution des gènes dans les peaks
DA_closePeaks_gene <- ClosestFeature(seurat_obj, regions = DA_closePeaks)
head(DA_closePeaks_gene)

# DA_openPeaks_gene <- ClosestFeature(seurat_obj, regions = DA_openPeaks)
# head(DA_openPeaks_gene)

```

```{r Gene Ontology}

# Sur les peaks qui sont plus fermés : 

# Code issu de l'analyse MARS ATAC = ne pas modifier
name_correspondace = bitr(DA_closePeaks_gene$gene_id, fromType = "ENSEMBL", toType = "ENTREZID", OrgDb = "org.Hs.eg.db")
colnames(DA_closePeaks_gene)[3] = "ENSEMBL"
# garder seulement les gènes dont on a trouvé la correspondance du nom dans la BDD
DA_closePeaks_gene = inner_join(DA_closePeaks_gene, name_correspondace, by = "ENSEMBL")

# ont = ALL => cellular components, cellular pathway...
ego <- enrichGO(gene = DA_closePeaks_gene$ENTREZID,
       OrgDb         = org.Hs.eg.db,
       ont           = "ALL",
       pAdjustMethod = "BH",
       pvalueCutoff  = 0.05,
       qvalueCutoff  = 0.2,
       readable      = TRUE)

dotplot(ego, showCategory = 20)


# refaire la même chose (ego) avec les foldchange positifs => pour avoir l'info de l'autre cluster
```

FONCTIONNEL : 

```{r, Clean Seurat Grange from weird chromosome names}

# à mettre au début ?
# https://www.biostars.org/p/9466838/
# https://kasperdanielhansen.github.io/genbioconductor/html/GenomicRanges_seqinfo.html

test = seurat_obj

test@assays$peaks # ChromatinAssay
test@assays$peaks@ranges # Grange avec 165 599 features (=peaks)

# pourquoi une différence ????
test@assays$peaks@ranges@seqnames 
table(test@assays$peaks@ranges@seqnames) # seqnames from grange
test@assays$peaks@seqinfo@seqnames 
table(test@assays$peaks@seqinfo@seqnames)

# Enelver les chromosomes bizarres
test@assays$peaks@ranges = keepStandardChromosomes(test@assays$peaks@ranges) # ne fonctionne pas 

# cette fonction permet d'enlever les noms bizarres dans ranges@seqnames
test@assays$peaks@ranges = keepStandardChromosomes(test@assays$peaks@ranges, pruning.mode = "coarse")
table(test@assays$peaks@ranges@seqnames)
test@assays$peaks@ranges # Grange avec 165 559 features (=peaks) => 40 peaks ont été enlevés (très peu donc pas de biais)

# mais pas dans seqinfo ? pourquoi ? 
table(test@assays$peaks@seqinfo@seqnames)
# a Seqinfo object containing allowed sequence names, lengths (or NA), and circularity flag, for each level in levels(seqnames). 
```

```{r, Associate genomic annotation to peaks in seurat object}

# A METTRE AU DEBUT ! 

# https://www.biostars.org/p/478325/
  
# grange de notre échantillon seurat_obj
# grange_sample = seurat_obj@assays$peaks@ranges # 165 599 ranges (=peaks)
# mcols(grange_sample)$annotation = "unassigned" # possibilité d'ajouter une colonne metadata 
# mcols(grange_sample)$gene_name = "unknown " # possibilité d'ajouter une colonne metadata 
# table(grange_sample$annotation) # objectif => remplir la colonne metadata avec les annotations
# table(grange_sample$gene_name) 
# 
# # grange de la BDD
# grange_annot = Annotation(seurat_obj) # 3 021 151 ranges (= peaks)
# levels(mcols(grange_annot)$type) # 703 128 cds, 1 101 668 exon, 940 523 gap, 275 832 utr
# table(grange_annot$type) # on veut extraire les peaks correspondant à la liste des 703128 peaks qui tombent dans cds
# # !!! on a ici tous les peaks de la BDD et pas ceux qui correspondent à l'échantillon !!! 
# 
# # Overlaps entre les deux granges 
# overlaps = findOverlaps(query = grange_sample, subject = grange_annot) # 897 646 hits 
# overlaps2 = findOverlaps(query = grange_sample, subject = grange_annot, select = "first") # premier de annot qui correspond à sample
# 
# # ajout de la colonne de metadonnées
# mcols(grange_sample)$annotation <- mcols(grange_annot)$type[overlaps2]
# mcols(grange_sample)$gene_name <- mcols(grange_annot)$gene_name[overlaps2]

######################################################################################################
# => problème avec les annotations => aller chercher le fichier FANTOM5 de MARSATAC

# grange => seurat_obj@assays$peaks@ranges

all_annotations = readRDS(paste0(dir_git, "/data/Annotation_TSS_pm1kb_int_ex_53utr_ctcf_cpg_woThisto_FANTOM5_prom_gr.rds"))

# cf script annotate grange pour ajouter les annotations
annotations_types = levels(factor(all_annotations$annotation))

# First a matrix is created filled with FALSE and added to the Grange
metadata = matrix(FALSE, ncol = length(annotations_types), nrow = length(seurat_obj@assays$peaks@ranges))
colnames(metadata) = annotations_types
mcols(seurat_obj@assays$peaks@ranges) = metadata # ajout de metadata : une colonne par annotation toutes à false au démarrage
# for each of the annotations types an overlap is calculated and used to assigned the peak as TRUE when overlapping with the annotation
for (i in 1:ncol(metadata)){
  sub_annot = all_annotations[all_annotations$annotation == annotations_types[i]]
  overlaps = findOverlaps(seurat_obj@assays$peaks@ranges, sub_annot)
  mcols(seurat_obj@assays$peaks@ranges)[queryHits(overlaps),i] = TRUE
}

colnames(mcols(seurat_obj@assays$peaks@ranges)) = case_when(colnames(mcols(seurat_obj@assays$peaks@ranges)) == "3' UTR" ~ "UTR3P",
                                colnames(mcols(seurat_obj@assays$peaks@ranges)) == "5' UTR" ~ "UTR5P",
                                colnames(mcols(seurat_obj@assays$peaks@ranges)) == "CpG Island" ~ "CpG",
                                colnames(mcols(seurat_obj@assays$peaks@ranges)) == "CTCF" ~ "CTCF",
                                colnames(mcols(seurat_obj@assays$peaks@ranges)) == "EXON" ~ "Exons",
                                colnames(mcols(seurat_obj@assays$peaks@ranges)) == "FANTOM5_promoter" ~ "FANTOM5_promoter",
                                colnames(mcols(seurat_obj@assays$peaks@ranges)) == "INTRON" ~ "Introns",
                                colnames(mcols(seurat_obj@assays$peaks@ranges)) == "Promoter_+-1000"  ~ "TSS_mp1kb")

mcols(seurat_obj@assays$peaks@ranges) = as_tibble(mcols(seurat_obj@assays$peaks@ranges)) %>%
  dplyr::mutate(Intergenic = ifelse(UTR3P == FALSE & 
                                    UTR5P == FALSE & 
                                    Exons == FALSE & 
                                    Introns == FALSE & 
                                    FANTOM5_promoter == FALSE & 
                                    TSS_mp1kb == FALSE, TRUE, FALSE)) %>%
  dplyr::mutate(CpG_Intergenic = ifelse(Intergenic == TRUE & CpG == TRUE, TRUE, FALSE)) %>%
  dplyr::mutate(CpG_Intergenic = ifelse(Intergenic == TRUE & CpG == TRUE, TRUE, FALSE)) %>%
  dplyr::mutate(CTCF_Intergenic = ifelse(Intergenic == TRUE & CTCF == TRUE, TRUE, FALSE)) %>%
  dplyr::mutate(CTCF_in_intron = ifelse(Introns == TRUE & CTCF == TRUE, TRUE, FALSE)) %>%
  dplyr::mutate(CTCF_in_exon = ifelse(Exons == TRUE & CTCF == TRUE, TRUE, FALSE))

seurat_obj@assays$peaks@ranges

rm(all_annotations, sub_annot, metadata, annotations_types)
```

```{r, Peaks distribution accross clusters, results = 'hold', fig.width=14, fig.height=6}

# OK fonctionnel
# https://github.com/satijalab/seurat/issues/1053

tab_peak_clust = data.frame(cell = character(), nbpeaks = numeric(), clust = character())
meta_col = paste0("peaks_snn_", res)

for ( i in 1:length(levels((seurat_obj@meta.data)[,meta_col])) ) {

  # Extract cluster number
  clust = levels((seurat_obj@meta.data)[,meta_col])[i]
  # Create subset of seurat object with cells from clust x
  expr = FetchData(object = seurat_obj, vars = meta_col)
  seurat_clust = seurat_obj[, which(x = (expr == clust))]
  # Check if the subset was correctly done
  print(table((seurat_clust@meta.data)[,meta_col])) 
  # Extract peak count matrix of clust x from general seurat object
  tab_clust = as.data.frame(GetAssayData(seurat_clust, slot = "data")) 
  # Transform count into logical
  tab_clust = tab_clust %>% mutate_all(as.logical)
  # Calculate number of peaks detected per cell
  tab_clust = data.frame(nbpeaks = colSums(tab_clust)) %>% 
    tibble::rownames_to_column(var = "cell") %>%
    dplyr::mutate(clust = clust)
  # Bind in general tab
  tab_peak_clust = rbind(tab_clust, tab_peak_clust)
  
}

tab_peak_stat = tab_peak_clust %>%
  dplyr::group_by(clust) %>%
  dplyr::mutate(nbcells = n(),
                median_nbpeaks = median(nbpeaks),
                mean_nbpeaks = round(mean(nbpeaks)),
                max_nbpeaks = max(nbpeaks),
                min_nbpeaks = min(nbpeaks),
                var_nbpeaks = round(sd(nbpeaks))) %>%
  dplyr::ungroup() %>%
  dplyr::select(clust, nbcells, median_nbpeaks, mean_nbpeaks, max_nbpeaks, min_nbpeaks, var_nbpeaks) %>%
  dplyr::distinct()
tab_peak_stat %>% kable(caption = res) %>% kable_styling()

tab_plot  = left_join(tab_peak_clust, tab_peak_stat)
plot_peak_clust = ggplot(tab_plot, aes(x = nbpeaks, fill = clust )) +
  geom_histogram(bins = 50, color = "black", alpha = 0.5) +
  geom_vline(aes(xintercept = median_nbpeaks, col = clust), linetype = "dashed", size = 1) +
  ggtitle(label = paste0("Distribution of peaks' number per cell according to cluster (with median) - ", res))
plot_peak_clust

# Save objects and clean working space
ggsave(plot = plot_peak_clust, 
       filename = paste0(dir_output, currentDate, "/plot_dim", dims_choice_char, "_", res, "_peaks_clust.png"), 
       width = 14, height = 6)
write_csv2(tab_peak_clust, file = paste0(dir_output, currentDate, "/tab_dim", dims_choice_char, "_",res, "_peaks_clust.csv"))
write_csv2(tab_peak_stat, file = paste0(dir_output, currentDate, "/tab_dim", dims_choice_char, "_", res, "_peaks_stat.csv"))
rm(i, clust, seurat_clust, tab_clust, plot_peak_clust, tab_peak_clust, tab_peak_stat, res, expr, meta_col, tab_plot)

```

EN COURS : 

```{r, TSS Peaks distribution accross clusters, results = 'hold', fig.width=14, fig.height=6}

# Extract cells from clust x (same code as earlier)
meta_col = paste0("peaks_snn_", res)
clust = levels((seurat_obj@meta.data)[,meta_col])[1] # test avec le cluster 0
expr = FetchData(object = seurat_obj, vars = meta_col)
seurat_clust = seurat_obj[, which(x = (expr == clust))]
print(table((seurat_clust@meta.data)[,meta_col])) 
# tab_clust = as.data.frame(GetAssayData(seurat_clust, slot = "data")) # Le cluster 0 contient 1971 cellules (en res 0.2)
# tab_clust = tab_clust[rowSums(tab_clust[])>0, ] # on enlève les peaks qui ne sont pas du tout détectés dans aucune cellule (tous les peaks sont détectés)
# list_peaks = data.frame(peak = rownames(tab_clust)) # pas très utile car tous les peaks sont détectés

# https://www.biostars.org/p/108080/
seurat_clust_tss = seurat_clust
seurat_clust_tss@assays$peaks@ranges = seurat_clust@assays$peaks@ranges[seurat_clust@assays$peaks@ranges$TSS_mp1kb == TRUE] 

seurat_clust@assays$peaks@ranges # 165 599 ranges 
seurat_clust_tss@assays$peaks@ranges # 9508 ranges

# Table avec toutes les cellules de l'échantillon et tous les peaks détectés : 5814 cellules et 165 599 peaks détectés
# tab_all = as.data.frame(GetAssayData(seurat_obj, slot = "data")) 
# list_peaks = data.frame(peak = rownames(tab_all))

# attention : quand on fait un subset de l'objet seurat, le grange annotation n'est pas modifié 
# # Extract annotations name from BDD grange store in seurat object
# grange_annot = Annotation(seurat_clust) # 3 021 151 ranges (= peaks)
# # idem que si on faisait Annotation(seurat_obj)
# levels(mcols(grange_annot)$type) # 703 128 cds, 1 101 668 exon, 940 523 gap, 275 832 utr
# table(grange_annot$type) # on veut extraire les peaks correspondant à la liste des 703128 peaks qui tombent dans cds
# # !!! on a ici tous les peaks de la BDD et pas ceux qui correspondent à l'échantillon !!! 
# # tab_annot = data.frame(seqnames = grange_annot@seqnames, 
# #                   ranges = grange_annot@ranges, 
# #                   type = grange_annot$type, 
# #                   gene_name = grange_annot$gene_name)
# # tab_annot = tab_annot %>% 
# #   dplyr::mutate(peak = paste0(seqnames, "-", ranges.start, "-", ranges.end)) %>%
# #   dplyr::select(peak, type, gene_name)
# # # mettre en relation le nom de nos peaks et leurs annotations
# test = full_join(list_peaks, tab_annot, by = "peak") # ne fonctionne pas car les peaks ne correspondent pas exactement il faut prendre les overlaps 
# Extraire les annotations correspondant aux peaks de clust0 uniquement 
# grange_clust = seurat_clust@assays$peaks@ranges # grange contenant les 165 599 peaks de l'échantillon 
# a = findOverlaps(query = grange_clust, subject = grange_annot)  # 897 646 hits détectés
# b = subjectHits(a) # récupération des indices des annotations ayant un hit avec les peaks du sample
# c = unique(b) # plus que 608 506 indices 
# annot_sample = grange_annot[c] # grange avec 897 646 éléments 


# création d'un grange avec seulement les peaks voulus 
library(plyranges) # https://support.bioconductor.org/p/133546/
grange_cds = grange %>% plyranges::filter(type == "cds") # grange contenant seulement les 703128 peaks cds
table(grange_cds$type)

# grange de Annotation => 3 021 151 ranges
# grange_cds => 703 128 ranges
# seurat_clust@assays$peaks@ranges
# grange de seurat_clust => 165 599 ranges ?

# a = findOverlaps(query = seurat_clust@assays$peaks@ranges, subject = grange)  
# b = queryHits
  
# verlap entre le seurat object et le grange_cds pour conserver seulement les peaks en commun

# https://www.biostars.org/p/473162/ 
# findOverlaps will return an index in each sample for every overlap. For the case where there are multiple overlaps for a range, there is an index created for each overlap. This is why changing the order of the subject and query doesn't change the number of rows.
# tss_overlap = findOverlaps(query = seurat_clust@assays$peaks, subject = grange_cds)
# tss_overlap = findOverlaps(query = seurat_clust, subject = grange_cds) # problème avec la queryLength 165599 ? il devrait être plus grand que subjectLength
# tss_ind = queryHits(tss_overlap) # 83652 ind => on devrait en avoir 703128 ?
# test = seurat_clust[tss_ind]
# grange_new = Annotation(test)
# table(grange_new$type)


# ne fonctionne pas 
# subsetByOverlaps(seurat_clust, grange_cds)
# FractionCountsInRegion(seurat_clust, grange_cds, assay = "peaks")
# ne fonctionne pas 
# test_obj = seurat_clust[which(Annotation(seurat_clust) == test_gr)]
# table(Annotation(test_obj)$type)
# ne fonctionne pas 
# test = seurat_clust[which(Annotation(seurat_clust)$type == "cds")]
# table(Annotation(test)$type)


# Idée Romuald
TSS_db_peaks = Annotation(seurat_clust)$type[which(Annotation(seurat_clust)$type == "cds")]
TSS_overlap = findOverlaps(seurat_clust$peaks, subject = TSS_db_peaks)
TSS_ind = queryOverlapHits(TSS_overlap)
seurat_clust[TSS_ind]

  
```

```{r, Peaks distribution accross clusters in annotations}
# pour chacun des deux clusters, faire la même distribution mais pour chaque élément/annotation génomique et faire les histogrammes comme pour le bulk
```

```{r, Cluster gene specific }

# sortir la liste de tous les gènes qui ont un peak dans le clust0, dans le clust1, enlever l'intersection et regarder ce qui n'est pas en commun :
  # - sous sampling que les peaks qui tombent dans TSS (refaire FindMarkers ?)
  # - utiliser closest feature sur tous ces peaks par cluster
  # - faire l'exclusion pour sortir la liste particulière de chaque cluster
  # - GO sur les deux listes

#################################
# sur touts les peaks 
#################################

meta_col = paste0("peaks_snn_res.0.2")

# Subset of seurat object to keep only cells from clust0
clust = "0"
expr = FetchData(object = seurat_obj, vars = meta_col)
seurat_clust0 = seurat_obj[, which(x = (expr == clust))]
# seurat_clust0@assays$peaks
# print(table((seurat_clust0@meta.data)[,meta_col])) 
# granges(seurat_clust0)
# Identify closest genes from peaks
clust0_gene <- ClosestFeature(seurat_clust0, regions = granges(seurat_clust0)) 
clust0_gene_list = as.vector(clust0_gene$gene_name)
# tous les peaks sont présents dans les deux clusters mais pas en même proportion ?

# Subset of seurat object to keep only cells from clust1
clust = "1"
expr = FetchData(object = seurat_obj, vars = meta_col)
seurat_clust1 = seurat_obj[, which(x = (expr == clust))]
# Identify closest genes from peaks
clust1_gene <- ClosestFeature(seurat_clust1, regions = granges(seurat_clust1))
clust1_gene_list = as.vector(clust1_gene$gene_name)

# pb : tous les gènes sont représentés dans les deux clusters, il faut s'intéresser aux proportions d'accessibilité
table(clust0_gene_list == clust1_gene_list)


################################################################################
# sur les 200 peaks les plus représentés (le plus de cellules qui le présentent)
################################################################################

tab_clust0 = as.data.frame(GetAssayData(seurat_clust0, slot = "data")) %>% mutate_all(as.logical)
tab_peak_clust0 = data.frame(nbcells = rowSums(tab_clust0)) %>% 
  tibble::rownames_to_column(var = "peak") %>%
  dplyr::arrange(desc(nbcells))
tab_top200 = head(tab_peak_clust0, 200)



```

```{r AddChromatinModule}

# Trouver des listes de gènes qui  nous intéressent, genre "souche, cellule T" ou bien même encore plus simplement les listes des gènes de chaque cluster de CALISTA (!)
# Choper les peaks qui tombe dans les TSS de ces gènes là
# Donner ces listes de gènes à la fonction AddChromatinModule
# Espèrer que le gros cluster corresponde au cluster 2 de Calista et que le petit au cluster 3/4/5
# Ou alors  espèrer que le gros cluster ait une signature plus "souche" que le cluster petit
```














